{"version":3,"file":"benchmark.js","sources":["../src/common.js","../src/find.js","../src/in-memory-store.js","../node_modules/avl/src/utils.js","../node_modules/avl/src/index.js","../src/indexes/baseindex.js","../src/indexes/avlindex.js","../src/indexes/hashindex.js","../src/indexes/binaryarray.js","../src/indexes/binaryindex.js","../bench/index.js"],"sourcesContent":["/**\n* Callback for comparer\n* @callback comparerCallback\n* @param   {Key} a\n* @param   {Key} b\n* @returns {number} -1 if a < b, 0 if a === b, 1 if a > b\n*/\n\n/**\n * Callback for item identifier\n * @callback itemCallback\n * @param   {any} item\n * @returns {any} unique value to identify the item\n */\n\n/**\n * Callback for key value\n * @callback keyCallback\n * @param   {any} item\n * @returns {any} value to index this item on\n */\n\n/**\n * Converts a passed value into an array.  Useful if you don't know\n * if your passed parameter is an array or single value.\n * @param  {any} items single item, array or javascript Map object\n * @return {Array<any>} array of passed item(s)\n */\nexport function oneOrMany(items) {\n  if (!items) {\n    return [];\n  } if (items instanceof Map) {\n    return Array.from(items.values());\n  } if (!Array.isArray(items)) {\n    return [items];\n  }\n  return items;\n}\n\n/**\n * Returns whether or not a < b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a <= b\n */\nexport function lte(comparer, a, b) {\n  return comparer(a, b) <= 0;\n}\n\n/**\n * Returns whether or not a > b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a => b\n */\nexport function gte(comparer, a, b) {\n  return comparer(a, b) >= 0;\n}\n\n/**\n * Returns whether or not a < b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a < b\n */\nexport function lt(comparer, a, b) {\n  return comparer(a, b) < 0;\n}\n\n/**\n * Returns whether or not a > b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a > b\n */\nexport function gt(comparer, a, b) {\n  return comparer(a, b) > 0;\n}\n\n/**\n * Returns whether or not a === b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a === b\n */\nexport function eq(comparer, a, b) {\n  return comparer(a, b) === 0;\n}\n\n/**\n * Default comparer equal to as used on Array.sort\n * @param  {any} a\n * @param  {any} b\n * @return {number} result of comparison\n */\nexport function defaultComparer(a, b) {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * Wraps any comparer with a call to .key on both a and b.\n * Useful if you comparer is a value comparer but the values\n * are objects with keys to compare.\n * @param  {comparerCallback} comparer comparer to use\n * @return {comparerCallback} comparer wrapped in .key calls\n */\nexport function keyWrapComparer(comparer) {\n  return (a, b) => comparer(a.key, b.key);\n}\n\n/**\n * Intersects N arrays\n * @param  {Array<Array<any>>} arrays N arrays with values to intersect\n * @return {Array<any>} array of values where that value is in all array\n */\nexport function intersect(arrays) {\n  const ordered = (arrays.length === 1\n    ? arrays\n    : arrays.sort((a1, a2) => a1.length - a2.length));\n  const shortest = ordered[0];\n  const set = new Set();\n  const result = [];\n\n  for (let i = 0; i < shortest.length; i += 1) {\n    const item = shortest[i];\n    let every = true; // don't use ordered.every ... it is slow\n    for (let j = 1; j < ordered.length; j += 1) {\n      if (!ordered[j].includes(item)) {\n        every = false;\n        break;\n      }\n    }\n    // ignore if not in every other array, or if already captured\n    if (every || !set.has(item)) {\n      // otherwise, add to book keeping set and the result\n      set.add(item);\n      result[result.length] = item;\n    }\n  }\n  return result;\n}\n\n/**\n * Extracts items passed by an array of keys from the passed map.\n * @param  {Map} map javascript map object containing all keys and values\n * @param  {Array<any>} keys keys to extract from the map\n * @return {Array<any>} array of values extracted from the passed map\n */\nexport function extract(map, keys) {\n  const r = [];\n  const manyKeys = oneOrMany(keys);\n  const defMap = map || new Map([]);\n\n  manyKeys.forEach((key) => {\n    if (map.has(key)) {\n      r.push(defMap.get(key));\n    }\n  });\n  return r;\n}\n\n/**\n * Flattens an array one level deep only.\n * @param  {Array<any>} arr array of arrays to flatten\n * @return {Array<any>} flattened array\n */\nexport function shallowFlat(arr) {\n  const resultArr = [];\n  if (!arr) {\n    return resultArr;\n  }\n  for (let i = 0; i < arr.length; i += 1) {\n    resultArr.push(...arr[i]);\n  }\n  return resultArr;\n}\n","import * as mem from './common';\n\n/**\n * Key value storage with support for grouping/returning items by index value\n */\nexport default class Find {\n  /**\n     * @param {Map<indexName, index>} indexes Map of indexes to query\n     */\n  constructor(indexes) {\n    this.indexes = indexes;\n  }\n\n  /**\n     * Searches one or many indexes, each using specified operator for specified value.\n     * @param {Array<any>} filters [{\"indexName\":{\"operator\":\"value\"}},\n     * {\"indexName\":{\"operator\":\"value\"}}]\n     * @returns {Array<any>} keys found in all passed index searches\n     */\n  $and(filters) {\n    const filterFns = this.getFilterFns(filters, this.indexes);\n    const dataSets = filterFns.map(fn => fn());\n    return mem.intersect(dataSets);\n  }\n\n  /**\n     * Searches one or many indexes, each using specified operator for specified value.\n     * @param {Array<any>} filters [{\"indexName\":{\"operator\":\"value\"}},\n     * {\"indexName\":{\"operator\":\"value\"}}]\n     * @returns {Array<any>} keys found in all passed index searches\n     */\n  $or(filters) {\n    const filterFns = this.getFilterFns(filters, this.indexes);\n    const dataSets = filterFns.map(fn => fn());\n    return dataSets.reduce((a, b) => a.concat(b), []);\n  }\n\n  /**\n     * Performs a find across many indexes based on limited find selector language.\n     * @param {Array<any>} selector\n     * { $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     * @returns {Array<any>} keys from found in all passed index searches\n     */\n  find(query) {\n    const selector = Find.parseQuery(query);\n    const joins = Object.keys(selector);\n    const fns = joins.map(op => this.combinatorFn(op, selector[op]));\n    const dataSets = fns.map(fn => fn());\n    // All operator results are ultimately $and together\n    return mem.intersect(dataSets);\n  }\n\n  /**\n     * Gets the combinator function based on the specified combinator key.\n     * @param {*} key Either $and or $or\n     * @param {*} filters The filters to pass through to the combinator.\n     */\n  combinatorFn(key, filters) {\n    switch (key) {\n      case '$and':\n        return () => this.$and(filters);\n      case '$or':\n        return () => this.$or(filters);\n      default:\n        return () => this.$and(filters);\n    }\n  }\n\n  /**\n     * Gets a filter function based on the specified operator key..\n     * @param {string} operator $lt/$gt/$gte/$lte or $eq\n     * @returns {any} function coresponding to passed key\n     */\n  static opertatorFn(key, index, val) {\n    switch (key) {\n      case '$lt':\n        return () => index.$lt(val);\n      case '$lte':\n        return () => index.$lte(val);\n      case '$gt':\n        return () => index.$gt(val);\n      case '$gte':\n        return () => index.$gte(val);\n      case '$in':\n        return () => index.$in(val);\n      case '$eq':\n        return () => index.$eq(val);\n      default:\n        return () => index.$eq(val);\n    }\n  }\n\n  /**\n     * Parses loose query language to strict with implicit operators and combinators\n     * made explicit.\n     * @param {*} query Query to parse in following supported formats...\n     * { $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     * OR (implicit $and)\n     * [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}]\n     * OR (implicit $eq)\n     * {\"indexName\":\"value\", \"indexName\":\"value\"}\n     * OR (implicit $in)\n     * {\"indexName\":\"value\", \"indexName\":[\"value1\", \"value1\"]}\n     * @returns {object} Strict query format in format...\n     * { $and: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     */\n  static parseQuery(query) {\n    const selector = {};\n    if (typeof query === 'object') {\n      const keys = Object.keys(query);\n\n      if (Array.isArray(query) || !Array.isArray(query[keys[0]])) {\n        // We've got a single item or array of items\n        selector.$and = [];\n        Find.parseInnerSelector(query, selector.$and);\n      } else {\n        // We've got a combinator\n        keys.forEach((key) => {\n          selector[key] = [];\n          Find.parseInnerSelector(query[key], selector[key]);\n        });\n      }\n    } else {\n      throw new SyntaxError(`Query should be an object or an array ${JSON.stringify(query)}`);\n    }\n    return selector;\n  }\n\n  static parseInnerSelector(query, selectors) {\n    // Inner selector should be an array\n    let manyQueries = query;\n    if (!Array.isArray(query)) {\n      manyQueries = [query];\n    }\n\n    const converted = manyQueries.map((part) => {\n      const selector = {};\n      if (typeof part !== 'object') {\n        throw new SyntaxError(`Selector part should be an object ${JSON.stringify(part)}`);\n      }\n\n      Object.keys(part).forEach((k) => {\n        // First part is always an index name (i.e. field name)\n        selector[k] = {};\n\n        // If it's an object, we've got an operator/key combination\n        // otherwise it's just a value\n        if (Array.isArray(part[k])) {\n          selector[k].$in = part[k];\n        } else if (typeof part[k] === 'object') {\n          const op = Object.keys(part[k])[0];\n          selector[k][op] = part[k][op];\n        } else {\n          selector[k].$eq = part[k];\n        }\n      });\n      return selector;\n    });\n\n    selectors.push(...converted);\n  }\n\n  /**\n     * Get function array based on specified find criteria.\n     * @param {Array<any>} filters [{\"indexName\":{\"operator\":\"value\"}},\n     * {\"indexName\":{\"operator\":\"value\"}}]\n     * @returns {Array<any>} Array of functions to perform specified find operations.\n     */\n  getFilterFns(filters) {\n    const manyFilters = mem.oneOrMany(filters);\n    return manyFilters.map((f) => {\n      // only one entry per filter\n      const filter = Object.entries(f)[0];\n      const indexName = filter[0];\n      const action = filter[1];\n\n      if (typeof action !== 'object') {\n        throw new TypeError(`Filter must contain a valid action object, passed filter ${filter}`);\n      }\n\n      const op = Object.keys(action)[0];\n      const val = action[op];\n\n      if (!this.indexes.has(indexName)) {\n        throw new TypeError(`Invalid index specified ${indexName}`);\n      }\n\n      return Find.opertatorFn(op, this.indexes.get(indexName), val);\n    });\n  }\n}\n","import * as mem from './common';\nimport Find from './find';\n\n/**\n * Key value storage with support for grouping/returning items by index value\n */\nexport default class InMemoryStore {\n  /**\n    * @param  {keyCallback} [keyFn] function to call to get the key of the items in this store\n    */\n  constructor(keyFn) {\n    this.indexes = new Map([]);\n    this.entries = new Map([]);\n    this.finder = new Find(this.indexes);\n    this.keyFn = keyFn;\n  }\n\n  /**\n     * Returns whether the store is empty\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.entries.size === 0;\n  }\n\n  /**\n     * Returns the number of items in the store\n     * @return {number}\n     */\n  get size() {\n    return this.entries.size;\n  }\n\n  /**\n     * Gets an index from the store by name.\n     * @param {string} name name of the index to get\n     * @returns {BaseIndex} index found\n     */\n  index(name) {\n    if (!this.indexes.has(name)) {\n      throw new Error(`Index ${name} not found in store`);\n    }\n    return this.indexes.get(name);\n  }\n\n  /**\n     * Returns all keys wihin the specified index\n     * @return {Array<Key>}\n     */\n  getIndexKeys(indexName) {\n    return this.indexes.get(indexName).keys;\n  }\n\n  /**\n     * Populates a new store with items using bulk load methods for indexes if available\n     * @param  {Array<any>} items items to populate store with\n     */\n  populate(items) {\n    if (!this.isEmpty) {\n      throw new Error(`Store must be empty to use populate. \n                Store currently has ${this.size} items.`);\n    }\n\n    const manyItems = mem.oneOrMany(items);\n    this.indexes.forEach(index => index.populate(manyItems));\n    const data = manyItems.map(item => [this.keyFn(item), item]);\n    this.entries = new Map(data);\n  }\n\n  /**\n     * Clears and re-populates a new store with items using bulk\n     * load methods for indexes if available\n     * @param  {Array<any>} items items to populate store with\n     */\n  rebuild(items) {\n    this.entries = new Map([]);\n    this.indexes.forEach(index => index.clear());\n    this.populate(items);\n  }\n\n  /**\n     * Clear the store\n     * @return {InMemoryStore}\n     */\n  destroy() {\n    this.indexes = new Map([]);\n    this.entries = new Map([]);\n    this.keyFn = undefined;\n  }\n\n  /**\n     * Whether the store contains an item with the given key\n     * @param  {Key} key\n     * @return {boolean} true/false\n     */\n  has(item) {\n    return this.entries.has(this.keyFn(item));\n  }\n\n  /**\n     * Performs a find across many indexes based on limited find selector language.\n     * @param {Array<any>} selector\n     * { $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     * @returns {Array<any>} items from the store found in all passed index searches\n     */\n  find(query) {\n    const data = this.finder.find(query);\n    return mem.extract(this.entries, data);\n  }\n\n  /**\n     * Returns items within specified index matching passed values\n     * @param  {string} indexName index to search\n     * @param  {Array<any>} values specified index values\n     * @return {Array<any>} values found\n     */\n  get(indexName, values) {\n    const data = this.indexes.has(indexName)\n      ? this.indexes.get(indexName).findMany(values) : [];\n    return mem.extract(this.entries, data);\n  }\n\n  /**\n     * Returns items within specified index matching passed value\n     * @param  {string} indexName index to search\n     * @param  {any} value specified index value\n     * @return {Array<any>} values found\n     */\n  getOne(indexName, value) {\n    const data = this.indexes.has(indexName)\n      ? this.indexes.get(indexName).find(value) : [];\n    return mem.extract(this.entries, data);\n  }\n\n  /**\n     * Adds a new index onto this store if it does not already exist. Populates index with entries\n     * if index not already populated.\n     * @param  {BaseIndex} index index ensure exists and is populated\n     * @return {boolean} true if index was added by this operation, false if already exists.\n     */\n  ensureIndex(index) {\n    if (!this.indexes.has(index.name)) {\n      this.indexes.set(index.name, index);\n      if (index.isEmpty) {\n        index.populate(this.entries);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n     * Removes items from the store and any associated indexes\n     * @param  {Array<any>} items items to remove\n     * @return {Array<boolean>} whether each remove succeeded (false if not found)\n     */\n  remove(items) {\n    const manyItems = mem.oneOrMany(items);\n    return manyItems.map(item => this.removeOne(item));\n  }\n\n  /**\n     * Removes an item from the store and any associated indexes\n     * @param  {any} item item to remove\n     * @return {boolean} whether remove succeeded (false if not found)\n     */\n  removeOne(item) {\n    if (this.indexes.size > 0) {\n      this.indexes.forEach(index => index.remove(item));\n    }\n    return this.entries.delete(this.keyFn(item));\n  }\n\n  /**\n     * Removes an item from the store by key and any associated indexes\n     * @param  {any} key key of item to remove\n     * @return {boolean} whether remove succeeded (false if not found)\n     */\n  removeKey(key) {\n    const item = this.entries.get(key);\n    if (!item) {\n      return false;\n    }\n    if (this.indexes.size > 0) {\n      this.indexes.forEach(index => index.remove(item));\n    }\n    return this.entries.delete(key);\n  }\n\n  /**\n     * Adds items to the store and updated any associated indexes\n     * @param  {Array<any>} items items to add\n     */\n  add(items) {\n    const manyItems = mem.oneOrMany(items);\n    manyItems.map(item => this.updateOne(item));\n  }\n\n  /**\n     * Adds an item to the store and updated any associated indexes\n     * @param  {any} item item to add\n     */\n  addOne(item) {\n    this.updateOne(item);\n  }\n\n  /**\n     * Updates items to the store and updated any associated indexes\n     * @param  {Array<any>} items items to update\n     */\n  update(items) {\n    const manyItems = mem.oneOrMany(items);\n    manyItems.forEach((item) => {\n      this.updateOne(item);\n    });\n  }\n\n  /**\n     * Updates an item in the store and updated any associated indexes\n     * @param  {any} item item to update\n     */\n  updateOne(item) {\n    let old;\n    const key = this.keyFn(item);\n    if (this.entries.has(key)) {\n      old = this.entries.get(key);\n    }\n    if (this.indexes.size > 0) {\n      this.indexes.forEach(index => index.update(item, old));\n    }\n    this.entries.set(key, item);\n  }\n}\n","\n/**\n * Prints tree horizontally\n * @param  {Node}                       root\n * @param  {Function(node:Node):String} [printNode]\n * @return {String}\n */\nexport function print (root, printNode = (n) => n.key) {\n  var out = [];\n  row(root, '', true, (v) => out.push(v), printNode);\n  return out.join('');\n}\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Function(in:string):void}    out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction row (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  row(root.left,  indent, false, out, printNode);\n    if (root.right) row(root.right, indent, true,  out, printNode);\n  }\n}\n\n\n/**\n * Is the tree balanced (none of the subtrees differ in height by more than 1)\n * @param  {Node}    root\n * @return {Boolean}\n */\nexport function isBalanced(root) {\n  if (root === null) return true; // If node is empty then return true\n\n  // Get the height of left and right sub trees\n  var lh = height(root.left);\n  var rh = height(root.right);\n\n  if (Math.abs(lh - rh) <= 1 &&\n      isBalanced(root.left)  &&\n      isBalanced(root.right)) return true;\n\n  // If we reach here then tree is not height-balanced\n  return false;\n}\n\n/**\n * The function Compute the 'height' of a tree.\n * Height is the number of nodes along the longest path\n * from the root node down to the farthest leaf node.\n *\n * @param  {Node} node\n * @return {Number}\n */\nfunction height(node) {\n  return node ? (1 + Math.max(height(node.left), height(node.right))) : 0;\n}\n\n\nexport function loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nexport function markBalance(node) {\n  if (node === null) return 0;\n  const lh = markBalance(node.left);\n  const rh = markBalance(node.right);\n\n  node.balanceFactor = lh - rh;\n  return Math.max(lh, rh) + 1;\n}\n\n\nexport function sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  // eslint-disable-next-line no-bitwise\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","import { print, isBalanced, loadRecursive, markBalance, sort } from './utils';\n\n\n// function createNode (parent, left, right, height, key, data) {\n//   return { parent, left, right, balanceFactor: height, key, data };\n// }\n\n/**\n * @typedef {{\n *   parent:        ?Node,\n *   left:          ?Node,\n *   right:         ?Node,\n *   balanceFactor: number,\n *   key:           Key,\n *   data:          Value\n * }} Node\n */\n\n/**\n * @typedef {*} Key\n */\n\n/**\n * @typedef {*} Value\n */\n\n/**\n * Default comparison function\n * @param {Key} a\n * @param {Key} b\n * @returns {number}\n */\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Single left rotation\n * @param  {Node} node\n * @return {Node}\n */\nfunction rotateLeft (node) {\n  var rightNode = node.right;\n  node.right    = rightNode.left;\n\n  if (rightNode.left) rightNode.left.parent = node;\n\n  rightNode.parent = node.parent;\n  if (rightNode.parent) {\n    if (rightNode.parent.left === node) {\n      rightNode.parent.left = rightNode;\n    } else {\n      rightNode.parent.right = rightNode;\n    }\n  }\n\n  node.parent    = rightNode;\n  rightNode.left = node;\n\n  node.balanceFactor += 1;\n  if (rightNode.balanceFactor < 0) {\n    node.balanceFactor -= rightNode.balanceFactor;\n  }\n\n  rightNode.balanceFactor += 1;\n  if (node.balanceFactor > 0) {\n    rightNode.balanceFactor += node.balanceFactor;\n  }\n  return rightNode;\n}\n\n\nfunction rotateRight (node) {\n  var leftNode = node.left;\n  node.left = leftNode.right;\n  if (node.left) node.left.parent = node;\n\n  leftNode.parent = node.parent;\n  if (leftNode.parent) {\n    if (leftNode.parent.left === node) {\n      leftNode.parent.left = leftNode;\n    } else {\n      leftNode.parent.right = leftNode;\n    }\n  }\n\n  node.parent    = leftNode;\n  leftNode.right = node;\n\n  node.balanceFactor -= 1;\n  if (leftNode.balanceFactor > 0) {\n    node.balanceFactor -= leftNode.balanceFactor;\n  }\n\n  leftNode.balanceFactor -= 1;\n  if (node.balanceFactor < 0) {\n    leftNode.balanceFactor += node.balanceFactor;\n  }\n\n  return leftNode;\n}\n\n\n// function leftBalance (node) {\n//   if (node.left.balanceFactor === -1) rotateLeft(node.left);\n//   return rotateRight(node);\n// }\n\n\n// function rightBalance (node) {\n//   if (node.right.balanceFactor === 1) rotateRight(node.right);\n//   return rotateLeft(node);\n// }\n\n\nexport default class AVLTree {\n  /**\n   * Callback for comparator\n   * @callback comparatorCallback\n   * @param {Key} a\n   * @param {Key} b\n   * @returns {number}\n   */\n\n  /**\n   * @class AVLTree\n   * @constructor\n   * @param  {comparatorCallback} [comparator]\n   * @param  {boolean}            [noDuplicates=false] Disallow duplicates\n   */\n  constructor (comparator, noDuplicates = false) {\n    this._comparator = comparator || DEFAULT_COMPARE;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  }\n\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  destroy() {\n    return this.clear();\n  }\n\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n  /**\n   * Number of nodes\n   * @return {number}\n   */\n  get size () {\n    return this._size;\n  }\n\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param  {Key} key\n   * @return {boolean} true/false\n   */\n  contains (key) {\n    if (this._root)  {\n      var node       = this._root;\n      var comparator = this._comparator;\n      while (node)  {\n        var cmp = comparator(key, node.key);\n        if      (cmp === 0) return true;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    }\n    return false;\n  }\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor.left) successor = successor.left;\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  }\n\n\n  /**\n   * Predecessor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor.right) predecessor = predecessor.right;\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  }\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * Callback for forEach\n   * @callback forEachCallback\n   * @param {Node} node\n   * @param {number} index\n   */\n\n  /**\n   * @param  {forEachCallback} callback\n   * @return {AVLTree}\n   */\n  forEach(callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range(low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns node with the minimum key\n   * @return {?Node}\n   */\n  minNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node;\n  }\n\n\n  /**\n   * Returns node with the max key\n   * @return {?Node}\n   */\n  maxNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node;\n  }\n\n\n  /**\n   * Min key\n   * @return {?Key}\n   */\n  min () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node.key;\n  }\n\n\n  /**\n   * Max key\n   * @return {?Key}\n   */\n  max () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node.key;\n  }\n\n\n  /**\n   * @return {boolean} true/false\n   */\n  isEmpty() {\n    return !this._root;\n  }\n\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) node = node.left;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n\n  /**\n   * Find node by key\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  find (key) {\n    var root = this._root;\n    // if (root === null)    return null;\n    // if (key === root.key) return root;\n\n    var subtree = root, cmp;\n    var compare = this._comparator;\n    while (subtree) {\n      cmp = compare(key, subtree.key);\n      if      (cmp === 0) return subtree;\n      else if (cmp < 0)   subtree = subtree.left;\n      else                subtree = subtree.right;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Insert a node into the tree\n   * @param  {Key} key\n   * @param  {Value} [data]\n   * @return {?Node}\n   */\n  insert (key, data) {\n    if (!this._root) {\n      this._root = {\n        parent: null, left: null, right: null, balanceFactor: 0,\n        key, data\n      };\n      this._size++;\n      return this._root;\n    }\n\n    var compare = this._comparator;\n    var node    = this._root;\n    var parent  = null;\n    var cmp     = 0;\n\n    if (this._noDuplicates) {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp === 0) return null;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    } else {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp <= 0)  node = node.left; //return null;\n        else                node = node.right;\n      }\n    }\n\n    var newNode = {\n      left: null,\n      right: null,\n      balanceFactor: 0,\n      parent, key, data\n    };\n    var newRoot;\n    if (cmp <= 0) parent.left  = newNode;\n    else         parent.right = newNode;\n\n    while (parent) {\n      cmp = compare(parent.key, key);\n      if (cmp < 0) parent.balanceFactor -= 1;\n      else         parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor === 0) break;\n      else if   (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      }\n      parent = parent.parent;\n    }\n\n    this._size++;\n    return newNode;\n  }\n\n\n  /**\n   * Removes the node from the tree. If not found, returns null.\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  remove (key) {\n    if (!this._root) return null;\n\n    var node = this._root;\n    var compare = this._comparator;\n    var cmp = 0;\n\n    while (node) {\n      cmp = compare(key, node.key);\n      if      (cmp === 0) break;\n      else if (cmp < 0)   node = node.left;\n      else                node = node.right;\n    }\n    if (!node) return null;\n\n    var returnValue = node.key;\n    var max, min;\n\n    if (node.left) {\n      max = node.left;\n\n      while (max.left || max.right) {\n        while (max.right) max = max.right;\n\n        node.key = max.key;\n        node.data = max.data;\n        if (max.left) {\n          node = max;\n          max = max.left;\n        }\n      }\n\n      node.key  = max.key;\n      node.data = max.data;\n      node = max;\n    }\n\n    if (node.right) {\n      min = node.right;\n\n      while (min.left || min.right) {\n        while (min.left) min = min.left;\n\n        node.key  = min.key;\n        node.data = min.data;\n        if (min.right) {\n          node = min;\n          min = min.right;\n        }\n      }\n\n      node.key  = min.key;\n      node.data = min.data;\n      node = min;\n    }\n\n    var parent = node.parent;\n    var pp     = node;\n    var newRoot;\n\n    while (parent) {\n      if (parent.left === pp) parent.balanceFactor -= 1;\n      else                    parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      }\n\n      if (parent.balanceFactor === -1 || parent.balanceFactor === 1) break;\n\n      pp     = parent;\n      parent = parent.parent;\n    }\n\n    if (node.parent) {\n      if (node.parent.left === node) node.parent.left  = null;\n      else                           node.parent.right = null;\n    }\n\n    if (node === this._root) this._root = null;\n\n    this._size--;\n    return returnValue;\n  }\n\n\n  /**\n   * Bulk-load items\n   * @param  {Array<Key>}  keys\n   * @param  {Array<Value>}  [values]\n   * @return {AVLTree}\n   */\n  load(keys = [], values = [], presort) {\n    if (this._size !== 0) throw new Error('bulk-load: tree is not empty');\n    const size = keys.length;\n    if (presort) sort(keys, values, 0, size - 1, this._comparator);\n    this._root = loadRecursive(null, keys, values, 0, size);\n    markBalance(this._root);\n    this._size = size;\n    return this;\n  }\n\n\n  /**\n   * Returns true if the tree is balanced\n   * @return {boolean}\n   */\n  isBalanced() {\n    return isBalanced(this._root);\n  }\n\n\n  /**\n   * String representation of the tree - primitive horizontal print-out\n   * @param  {Function(Node):string} [printNode]\n   * @return {string}\n   */\n  toString (printNode) {\n    return print(this._root, printNode);\n  }\n}\n\nAVLTree.default = AVLTree;\n","/* eslint class-methods-use-this: 0 */\nimport * as mem from '../common';\n\n/**\n * Base index for use with in-memory-store\n */\nexport default class BaseIndex {\n  /**\n     * @param  {string} name name of this index\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\n     * @param  {itemCallback} itemFn function to call to get the unique item key of the\n     * items in this index\n     */\n  constructor(name, itemFn, keyFn) {\n    if (this.constructor === BaseIndex) {\n      throw new TypeError('Cannot construct BaseIndex directly');\n    }\n\n    this.name = name;\n    this.itemFn = itemFn;\n    this.keyFn = keyFn;\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    throw new TypeError('Must implement isEmpty property');\n  }\n\n  /**\n     * Returns all keys\n     * @abstract\n     * @return {Array<Key>}\n     */\n  get keys() {\n    throw new TypeError('Must implement keys property');\n  }\n\n  /**\n     * Removes all items from the index\n     * @abstract\n     */\n  clear() {\n    throw new TypeError('Must implement clear method');\n  }\n\n  /**\n     * Returns items within matching passed index keys\n     * @param  {Array<any>} keys specified index keys\n     * @return {Array<any>} values found\n     */\n  findMany(keys) {\n    const manyKeys = mem.oneOrMany(keys);\n    const data = manyKeys.map(m => this.find(m));\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @abstract\n     * @return {Array<any>} values found\n     */\n  find() {\n    throw new TypeError('Must implement find method');\n  }\n\n  /**\n     * Removes an item\n     * @abstract\n     */\n  remove() {\n    throw new TypeError('Must implement build method');\n  }\n\n  /**\n     * Populates this index with new items and indexes\n     * as per itemFn and keyFn defined on index creation\n     * @param  {Array<any>} items items to populate store with\n     */\n  populate(items) {\n    if (!this.isEmpty) {\n      throw new Error(`${typeof this} index must be empty in order to use populate`);\n    }\n\n    const manyItems = mem.oneOrMany(items);\n    manyItems.forEach(item => this.insert(item));\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @abstract\n     */\n  insert() {\n    throw new TypeError('Must implement insert method');\n  }\n\n  /**\n     * Updates an item by removing any associated index entry based on oldItem and adding new index\n     * entries based on the new item.  Important to pass oldItem otherwise index\n     * may contain entries from item in wrong indexed key.\n     * @param  {any} oldItem item as it was prior to being updated\n     * @param  {any} item item as it is now\n     */\n  update(item, olditem) {\n    if (olditem) {\n      this.remove(olditem);\n    }\n    this.insert(item);\n  }\n}\n","/* eslint import/no-extraneous-dependencies: [\"error\", {\"optionalDependencies\": true}] */\nimport AVLTree from 'avl';\nimport * as mem from '../common';\nimport BaseIndex from './baseindex';\n\n/**\n * Index based on AVL Tree object for key/value storage. Groups items by index value,\n * stores items within index value as array using linear search.\n * @extends {BaseIndex}\n */\nexport default class AVLIndex extends BaseIndex {\n  /**\n     * @param  {string} name name of this index\n     * @param  {itemCallback} itemFn function to call to get the unique item\n     * key of the items in this index\n     * @param  {keyCallback} keyFn function to call to get the index key\n     * of the items in this index\n     * @param  {comparerCallback} [comparer] comparer to use when comparing\n     * one index value to another\n     */\n  constructor(name, itemFn, keyFn, comparer) {\n    super(name, itemFn, keyFn);\n    this.comparer = comparer || mem.defaultComparer;\n    this.index = new AVLTree(comparer);\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.index.size === 0;\n  }\n\n  /**\n     * Returns all keys\n     * @return {Array<Key>}\n     */\n  get keys() {\n    return this.index.keys();\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.index.clear();\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lt(key) {\n    let lastKey;\n    const data = [];\n    this.index.range(this.index.min, key, (n) => {\n      lastKey = n.key;\n      data.push(n.data);\n    });\n    if (data.length === 0) {\n      return [];\n    }\n    // Since Tree is unique, we only need to check last key to omit\n    if (mem.eq(this.comparer, lastKey, key)) {\n      data.pop();\n    }\n    return data;\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lte(key) {\n    const data = [];\n    this.index.range(this.index.min, key, (n) => {\n      data.push(n.data);\n    });\n    return data;\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gt(key) {\n    let firstKey;\n    const data = [];\n    this.index.range(key, this.index.max, (n) => {\n      if (firstKey === undefined) {\n        firstKey = n.key;\n      }\n      data.push(n.data);\n    });\n    if (data.length === 0) {\n      return [];\n    }\n    // Since Tree is unique, we only need to check first key to omit\n    if (mem.eq(this.comparer, firstKey, key)) {\n      data.shift();\n    }\n    return data;\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gte(key) {\n    const data = [];\n    this.index.range(key, this.index.max, (n) => {\n      data.push(n.data);\n    });\n    return data;\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  $eq(key) {\n    return this.find(key);\n  }\n\n  /**\n     * Returns items matching passed index keys\n     * @param  {Array<any>} key specified index keys\n     * @return {Array<any>} values found\n     */\n  $in(keys) {\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  find(key) {\n    const found = this.index.find(key);\n    if (found) {\n      return found.data;\n    }\n    return [];\n  }\n\n  /**\n     * Removes an item\n     * @param  {any} item item to remove\n     */\n  remove(item) {\n    const key = this.keyFn(item);\n    const entry = this.index.find(key);\n\n    if (entry) {\n      const it = this.itemFn(item);\n      const arr = entry.data;\n      const i = arr.indexOf(it);\n      if (i > -1) {\n        arr.splice(i, 1);\n      }\n      if (arr.length === 0) {\n        this.index.remove(key);\n      }\n    }\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @param  {any} item item to add to index\n     */\n  insert(item) {\n    const key = this.keyFn(item);\n    const it = this.itemFn(item);\n    const entry = this.index.find(key);\n\n    if (entry) {\n      entry.data.push(it);\n    } else {\n      this.index.insert(key, [it]);\n    }\n  }\n}\n","import * as mem from '../common';\nimport BaseIndex from './baseindex';\n\n/**\n * Index based on javascript Map object for key/value storage. Groups items by index value,\n * stores items within index value as array using linear search.\n * @extends {BaseIndex}\n */\nexport default class HashIndex extends BaseIndex {\n  /**\n     * @param  {string} name name of this index\n     * @param  {itemCallback} itemFn function to call to get the unique item key\n     * of the items in this index\n     * @param  {keyCallback} keyFn function to call to get the index key of the\n     * items in this index\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one\n     * index value to another\n     */\n  constructor(name, itemFn, keyFn, comparer) {\n    super(name, itemFn, keyFn);\n    this.comparer = comparer || mem.defaultComparer;\n    this.index = new Map([]);\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.index.size === 0;\n  }\n\n  /**\n     * Returns all keys\n     * @return {Array<Key>}\n     */\n  get keys() {\n    return Array.from(this.index.keys());\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lt(key) {\n    const keys = this.keys.filter(k => mem.lt(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lte(key) {\n    const keys = this.keys.filter(k => mem.lte(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns all entries greater than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gt(key) {\n    const keys = this.keys.filter(k => mem.gt(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gte(key) {\n    const keys = this.keys.filter(k => mem.gte(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  $eq(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Returns items matching passed index keys\n     * @param  {Array<any>} key specified index keys\n     * @return {Array<any>} values found\n     */\n  $in(keys) {\n    return this.findMany(keys);\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.index = new Map([]);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  find(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Removes an item\n     * @param  {any} item item to remove\n     */\n  remove(item) {\n    const key = this.keyFn(item);\n    if (this.index.has(key)) {\n      const col = this.index.get(key);\n      const it = this.itemFn(item);\n      const i = col.indexOf(it);\n      if (i > -1) {\n        col.splice(i, 1);\n      }\n      if (col.length === 0) {\n        this.index.delete(key);\n      }\n    }\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @param  {any} item item to add to index\n     */\n  insert(item) {\n    const key = this.keyFn(item);\n    const it = this.itemFn(item);\n    if (it && key) {\n      if (this.index.has(key)) {\n        this.index.get(key).push(it);\n      } else {\n        this.index.set(key, [it]);\n      }\n    }\n  }\n}\n","import * as mem from '../common';\n\n/**\n * Binary key/value storage backed by native javascript array. Performs binary search on entries and\n * keeps items in sorted order based on comparer.\n */\nexport default class BinaryArray {\n  /**\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one\n     * index value to another\n     */\n  constructor(comparer) {\n    this.arr = [];\n    this.comparer = comparer || mem.defaultComparer;\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.arr = [];\n  }\n\n  /**\n     * Returns an array of keys stored in this Key Value array\n     * @returns {Array<any>} all keys\n     */\n  get keys() {\n    return this.arr.map(m => m.key);\n  }\n\n  /**\n     * Returns an array of values stored in this Key Value array\n     * @returns {Array<any>} all values\n     */\n  get values() {\n    return this.arr.map(m => m.value);\n  }\n\n  /**\n     * Returns the number of items in this BinaryArray\n     * @returns {number}\n     */\n  get length() {\n    return this.arr.length;\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  lt(key) {\n    const i = this.insertPos(key);\n    const data = this.arr.slice(0, i);\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  lte(key) {\n    const i = this.insertPos(key);\n    const data = i >= 0 ? this.arr.slice(0, i + 1) : [];\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns all entries greater than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  gt(key) {\n    const i = this.insertPos(key);\n    const data = i < this.arr.length ? this.arr.slice(i + 1, this.arr.length) : [];\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  gte(key) {\n    const i = this.insertPos(key);\n    const data = i < this.arr.length ? this.arr.slice(i, this.arr.length) : [];\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns the index in this array of the specified key\n     * @param {any} key\n     * @returns {number}\n     */\n  indexOf(key) {\n    const i = this.insertPos(key);\n    if (this.arr[i] && mem.eq(this.comparer, this.arr[i].key, key)) {\n      return i;\n    }\n    return -1;\n  }\n\n  /**\n     * The insert position where to insert an item into the underlying sorted array.\n     * @param {any} key key to find in the array\n     * @returns {number} position at which a new item should be inserted into this array\n     */\n  insertPos(key) {\n    let low = 0; let high = this.arr.length; let\n      mid;\n    while (low < high) {\n      /* eslint no-bitwise: 0 */\n      mid = (low + high) >>> 1;\n      if (mem.lt(this.comparer, this.arr[mid].key, key)) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return low;\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {any} value found\n     */\n  get(key) {\n    const i = this.indexOf(key);\n    if (i > -1) {\n      return this.arr[i].value;\n    }\n    return undefined;\n  }\n\n  /**\n     * Returns whether or not a given key exists.\n     * @param  {any} key specified index key\n     * @return {boolean} if key exists or not\n     */\n  has(key) {\n    const i = this.indexOf(key);\n    return (i > -1);\n  }\n\n  /**\n     * Removes an item by key\n     * @param  {any} key key of item to remove\n     */\n  remove(key) {\n    const i = this.indexOf(key);\n    if (i > -1) {\n      this.removeAt(i);\n    }\n  }\n\n  /**\n     * Adds an key/value with array\n     * @param  {any} key key to add\n     * @param  {any} value item related to the specified key\n     */\n  add(key, value) {\n    const ix = this.insertPos(key);\n    this.addAt(ix, key, value);\n  }\n\n  /**\n     * Replaces an existing entry in the array with a new one.\n     * @param {any} key key to add\n     * @param {any} value item related to the specified key\n     */\n  replace(key, value) {\n    const i = this.indexOf(key);\n    if (i > -1) {\n      this.replaceAt(i, key, value);\n    }\n  }\n\n  /**\n     * Adds a key/value entry at a specified position in the array.\n     * Will not replace any existing item in that postion, instead\n     * inserting before it.\n     * @param {number} pos index of where to add this entry\n     * @param {any} key key to add\n     */\n  addAt(pos, key, value) {\n    const item = { key, value };\n    this.arr.splice(pos, 0, item);\n  }\n\n  /**\n     * Replaces an existing entry in the array at specified position with a new one.\n     * @param {number} pos index of where to replace this entry\n     * @param {any} key key to add\n     * @param {any} value item related to the specified key\n     */\n  replaceAt(pos, key, value) {\n    const item = { key, value };\n    this.arr.splice(pos, 1, item);\n  }\n\n  /**\n     * Removes a key/value entry at a specified position\n     * @param {number} pos index of the item to remove.\n     */\n  removeAt(pos) {\n    this.arr.splice(pos, 1);\n  }\n\n  /**\n     * Returns key matching passed index position\n     * @param  {number} pos index of where to add this entry\n     * @return {any} key found at this position\n     */\n  getAt(pos) {\n    return this.arr[pos];\n  }\n}\n","import * as mem from '../common';\nimport BinaryArray from './binaryarray';\nimport BaseIndex from './baseindex';\n\n/**\n * Index based on BinaryArray for key/value storage. Groups items by index value,\n * stores items within index value as array using linear search.\n * @extends {BaseIndex}\n */\nexport default class BinaryIndex extends BaseIndex {\n  /**\n     * @implements {BaseIndex}\n     * @param  {string} name name of this index\n     * @param  {itemCallback} itemFn function to call to get the unique item\n     * key of the items in this index\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\n     * @param  {comparerCallback} [comparer] comparer to use when comparing\n     * one index value to another\n     */\n  constructor(name, itemFn, keyFn, comparer) {\n    super(name, itemFn, keyFn);\n    this.comparer = comparer || mem.defaultComparer;\n    this.index = new BinaryArray(this.comparer);\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.index.length === 0;\n  }\n\n  /**\n     * Returns all keys\n     * @return {Array<Key>}\n     */\n  get keys() {\n    return this.index.keys;\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.index = new BinaryArray(this.comparer);\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lt(key) {\n    const data = this.index.lt(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lte(key) {\n    const data = this.index.lte(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns all entries greater than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gt(key) {\n    const data = this.index.gt(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gte(key) {\n    const data = this.index.gte(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  $eq(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Returns items matching passed index keys\n     * @param  {Array<any>} key specified index keys\n     * @return {Array<any>} values found\n     */\n  $in(keys) {\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  find(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Removes an item\n     * @param  {any} item item to remove\n     */\n  remove(item) {\n    const key = this.keyFn(item);\n    const pos = this.index.indexOf(key);\n\n    if (pos > -1) {\n      const entry = this.index.getAt(pos);\n      const it = this.itemFn(item);\n      const i = entry.value.indexOf(it);\n      if (i > -1) {\n        entry.value.splice(i, 1);\n      }\n      if (entry.value.length === 0) {\n        this.index.removeAt(pos);\n      }\n    }\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @param  {any} item item to add to index\n     */\n  insert(item) {\n    const key = this.keyFn(item);\n    const it = this.itemFn(item);\n    const pos = this.index.insertPos(key);\n    const entry = this.index.getAt(pos);\n\n    if (entry && mem.eq(this.comparer, entry.key, key)) {\n      entry.value.push(it);\n    } else {\n      this.index.addAt(pos, key, [it]);\n    }\n  }\n}\n","// Exports all modules needed for our benchmark test\n// Includes modules not packaged with in-memory-store\nimport InMemoryStore from '../src/in-memory-store';\nimport AVLIndex from '../src/indexes/avlindex';\nimport HashIndex from '../src/indexes/hashindex';\nimport BinaryIndex from '../src/indexes/binaryindex';\n\nexport {\n  InMemoryStore,\n  AVLIndex,\n  HashIndex,\n  BinaryIndex,\n};\n"],"names":["const","let","mem.intersect","this","mem.oneOrMany","mem.extract","prototypeAccessors","mem.shallowFlat","super","mem.defaultComparer","mem.eq","mem.lt","mem.lte","mem.gt","mem.gte"],"mappings":"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"}