{"version":3,"file":"in-memory-store.es6.js","sources":["../src/common.js","../src/in-memory-store.js","../src/indexes/baseindex.js","../src/indexes/hashindex.js","../src/indexes/binaryarray.js","../src/indexes/binaryindex.js","../src/indexes/avlindex.js"],"sourcesContent":["/**\r\n* Callback for comparer\r\n* @callback comparerCallback\r\n* @param   {Key} a\r\n* @param   {Key} b\r\n* @returns {number} -1 if a < b, 0 if a === b, 1 if a > b\r\n*/\r\n\r\n/**\r\n * Callback for item identifier\r\n * @callback itemCallback\r\n * @param   {any} item\r\n * @returns {any} unique value to identify the item\r\n */\r\n\r\n/**\r\n * Callback for key value\r\n * @callback keyCallback\r\n * @param   {any} item\r\n * @returns {any} value to index this item on\r\n */\r\n\r\n/**\r\n * Converts a passed value into an array.  Useful if you don't know\r\n * if your passed parameter is an array or single value.\r\n * @param  {any} items single item, array or javascript Map object\r\n * @return {Array<any>} array of passed item(s)\r\n */\r\nexport function oneOrMany(items) {\r\n    if (!items) {\r\n        return [];\r\n    } else if (items instanceof Map) {\r\n        return Array.from(items.values());\r\n    } else if (!Array.isArray(items)) {\r\n        return [items];\r\n    } else {\r\n        return items;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns whether or not a < b\r\n * @param  {comparerCallback} comparer comparer to use\r\n * @param  {any} a \r\n * @param  {any} b \r\n * @return {boolean} whether or not a <= b\r\n */\r\nexport function lte(comparer, a, b) {\r\n    return comparer(a, b) <= 0;\r\n}\r\n\r\n/**\r\n * Returns whether or not a > b\r\n * @param  {comparerCallback} comparer comparer to use\r\n * @param  {any} a \r\n * @param  {any} b \r\n * @return {boolean} whether or not a => b\r\n */\r\nexport function gte(comparer, a, b) {\r\n    return comparer(a, b) >= 0;\r\n}\r\n\r\n/**\r\n * Returns whether or not a < b\r\n * @param  {comparerCallback} comparer comparer to use\r\n * @param  {any} a \r\n * @param  {any} b \r\n * @return {boolean} whether or not a < b\r\n */\r\nexport function lt(comparer, a, b) {\r\n    return comparer(a, b) < 0;\r\n}\r\n\r\n/**\r\n * Returns whether or not a > b\r\n * @param  {comparerCallback} comparer comparer to use\r\n * @param  {any} a \r\n * @param  {any} b \r\n * @return {boolean} whether or not a > b\r\n */\r\nexport function gt(comparer, a, b) {\r\n    return comparer(a, b) > 0;\r\n}\r\n\r\n/**\r\n * Returns whether or not a === b\r\n * @param  {comparerCallback} comparer comparer to use\r\n * @param  {any} a \r\n * @param  {any} b \r\n * @return {boolean} whether or not a === b\r\n */\r\nexport function eq(comparer, a, b) {\r\n    return comparer(a, b) === 0;\r\n}\r\n\r\n/**\r\n * Default comparer equal to as used on Array.sort\r\n * @param  {any} a \r\n * @param  {any} b \r\n * @return {number} result of comparison\r\n */\r\nexport function defaultComparer(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n\r\n/**\r\n * Wraps any comparer with a call to .key on both a and b.\r\n * Useful if you comparer is a value comparer but the values\r\n * are objects with keys to compare.\r\n * @param  {comparerCallback} comparer comparer to use\r\n * @return {comparerCallback} comparer wrapped in .key calls\r\n */\r\nexport function keyWrapComparer(comparer) {\r\n    return function(a, b) {\r\n        return comparer(a.key, b.key);\r\n    };\r\n}\r\n\r\n/**\r\n * Intersects N arrays\r\n * @param  {Array<Array<any>>} arrays N arrays with values to intersect\r\n * @return {Array<any>} array of values where that value is in all array\r\n */\r\nexport function intersect(arrays) {\r\n    const ordered = (arrays.length === 1\r\n        ? arrays : \r\n        arrays.sort((a1,a2) => a1.length - a2.length));\r\n    const shortest = ordered[0],\r\n        set = new Set(), \r\n        result = [];\r\n\r\n    for (let i=0; i < shortest.length; i++) {\r\n        const item = shortest[i];\r\n        let every = true; // don't use ordered.every ... it is slow\r\n        for(let j=1;j<ordered.length;j++) {\r\n            if(ordered[j].includes(item)) continue;\r\n            every = false;\r\n            break;\r\n        }\r\n        // ignore if not in every other array, or if already captured\r\n        if(!every || set.has(item)) continue;\r\n        // otherwise, add to book keeping set and the result\r\n        set.add(item);\r\n        result[result.length] = item;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Extracts items passed by an array of keys from the passed map.\r\n * @param  {Map} map javascript map object containing all keys and values\r\n * @param  {Array<any>} keys keys to extract from the map\r\n * @return {Array<any>} array of values extracted from the passed map\r\n */\r\nexport function extract(map, keys) {\r\n    const r = [];\r\n    keys = oneOrMany(keys);\r\n    map = map || new Map([]);\r\n    \r\n    keys.forEach((key) => {\r\n        if (map.has(key)) {\r\n            r.push(map.get(key));\r\n        }\r\n    });    \r\n    return r;\r\n}","import * as mem from './common';\r\n\r\n/**\r\n * Key value storage with support for grouping/returning items by index value\r\n */\r\nexport class InMemoryStore {\r\n   /**\r\n    * @param  {keyCallback} [keyFn] function to call to get the key of the items in this store\r\n    */\r\n    constructor(keyFn) {\r\n        this.indexes = new Map([]);\r\n        this.entries = new Map([]);\r\n        this.keyFn = keyFn;        \r\n    }\r\n\r\n    /**\r\n     * Returns whether the store is empty\r\n     * @return {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return this.entries.size === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of items in the store\r\n     * @return {number}\r\n     */\r\n    get size() {\r\n        return this.entries.size;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not this store is empty\r\n     * @abstract\r\n     * @return {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return this.size === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns all keys wihin the specified index\r\n     * @return {Array<Key>}\r\n     */\r\n    getIndexKeys(indexName) {\r\n        return this.indexes.get(indexName).keys;\r\n    }\r\n\r\n    /**\r\n     * Populates a new store with items using bulk load methods for indexes if available\r\n     * @param  {Array<any>} items items to populate store with\r\n     */\r\n    populate(items) {\r\n        if (!this.isEmpty) {\r\n            throw new Error(`Store must be empty to use populate. \r\n                Store currently has ${this.size} items.`);\r\n        }\r\n\r\n        items = mem.oneOrMany(items);\r\n        this.indexes.forEach(index => index.populate(items));\r\n        const data = items.map(item => [this.keyFn(item), item]);\r\n        this.entries = new Map(data);\r\n    }\r\n\r\n    /**\r\n     * Clears and re-populates a new store with items using bulk \r\n     * load methods for indexes if available\r\n     * @param  {Array<any>} items items to populate store with\r\n     */\r\n    rebuild(items) {\r\n        this.entries = new Map([]);\r\n        this.indexes.forEach(index => index.clear());\r\n        this.populate(items);\r\n    }\r\n\r\n    /**\r\n     * Clear the store\r\n     * @return {InMemoryStore}\r\n     */\r\n    destroy() {\r\n        this.indexes = new Map([]);\r\n        this.entries = new Map([]);\r\n        this.keyFn = undefined;\r\n    }\r\n    \r\n    /**\r\n     * Whether the store contains an item with the given key\r\n     * @param  {Key} key\r\n     * @return {boolean} true/false\r\n     */\r\n    has(item) {\r\n        return this.entries.has(this.keyFn(item));\r\n    }\r\n\r\n    /**\r\n     * Returns items within specified index matching passed values\r\n     * @param  {string} indexName index to search\r\n     * @param  {Array<any>} values specified index values\r\n     * @return {Array<any>} values found\r\n     */\r\n\tget(indexName, values) {\r\n        const data = this.indexes.has(indexName) ? \r\n            this.indexes.get(indexName).findMany(values) : [];\r\n        return mem.extract(this.entries, data);\r\n    }\r\n\r\n    /**\r\n     * Returns items within specified index matching passed value\r\n     * @param  {string} indexName index to search\r\n     * @param  {any} value specified index value\r\n     * @return {Array<any>} values found\r\n     */\r\n    getOne(indexName, value) {\r\n        const data = this.indexes.has(indexName) ? \r\n            this.indexes.get(indexName).find(value) : [];\r\n        return mem.extract(this.entries, data);\r\n    }\r\n\r\n    // Takes array of [indexName, [exactMatch, exactMatch]]\r\n    /**\r\n     * Searches many indexes each with many values and intersects the results\r\n     * @param  {Array<string, Array<any>>} valueSet [indexName, [exactMatch, exactMatch]]\r\n     * @return {Array<any>} values found\r\n     */\r\n    getFromSet(valueSet) {\r\n        const dataSets = valueSet.map((q) => {\r\n            return this.get(q[0], q[1]);\r\n        });\r\n        const data = mem.intersect(dataSets);\r\n        return mem.extract(this.entries, data);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less than the passed value according to the\r\n     * indexes comparer.\r\n     * @param  {string} indexName index to search\r\n     * @param {any} value \r\n     */\r\n    lt(indexName, value) {\r\n        const data = this.indexes.has(indexName) ? \r\n            this.indexes.get(indexName).lt(value) : [];\r\n        return mem.extract(this.entries, data);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less or equal to the passed value according to the\r\n     * indexes comparer.\r\n     * @param  {string} indexName index to search\r\n     * @param {any} value \r\n     */\r\n    lte(indexName, key) {\r\n        const data = this.indexes.has(indexName) ? \r\n            this.indexes.get(indexName).lte(value) : [];\r\n        return mem.extract(this.entries, data);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than the passed value according to the\r\n     * indexes comparer.\r\n     * @param  {string} indexName index to search\r\n     * @param {any} value \r\n     */\r\n    gt(indexName, value) {\r\n        const data = this.indexes.has(indexName) ? \r\n            this.indexes.get(indexName).gt(value) : [];\r\n        return mem.extract(this.entries, data);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than or equal to the passed value according to the\r\n     * indexes comparer.\r\n     * @param  {string} indexName index to search\r\n     * @param {any} value \r\n     */\r\n    gte(indexName, value) {\r\n        const data = this.indexes.has(indexName) ? \r\n            this.indexes.get(indexName).gte(value) : [];\r\n        return mem.extract(this.entries, data);\r\n    }\r\n\r\n    /**\r\n     * Adds a new index onto this store if it does not already exist. Populates index with entries\r\n     * if index not already populated.\r\n     * @param  {BaseIndex} index index ensure exists and is populated\r\n     * @return {boolean} true if index was added by this operation, false if already exists.\r\n     */\r\n    ensureIndex(index) {\r\n        if (!this.indexes.has(index.name)) {\r\n            this.indexes.set(index.name, index);\r\n            if (index.isEmpty) {\r\n                index.populate(this.entries);\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes items from the store and any associated indexes\r\n     * @param  {Array<any>} items items to remove\r\n     * @return {Array<boolean>} whether each remove succeeded (false if not found)\r\n     */\r\n    remove(items) {\r\n        items = mem.oneOrMany(items);\r\n        return items.map(item => this.removeOne(item));\r\n    }\r\n\r\n    /**\r\n     * Removes an item from the store and any associated indexes\r\n     * @param  {any} item item to remove\r\n     * @return {boolean} whether remove succeeded (false if not found)\r\n     */\r\n    removeOne(item) {\r\n        if (this.indexes.size > 0) {\r\n            this.indexes.forEach(index => index.remove(item));\r\n        }\r\n        return this.entries.delete(this.keyFn(item));\r\n    }\r\n\r\n    /**\r\n     * Removes an item from the store by key and any associated indexes\r\n     * @param  {any} key key of item to remove\r\n     * @return {boolean} whether remove succeeded (false if not found)\r\n     */\r\n    removeKey(key) {\r\n        const item = this.entries.get(key);\r\n        if (!item) {\r\n            return false;\r\n        }\r\n        if (this.indexes.size > 0) {\r\n            this.indexes.forEach(index => index.remove(item));\r\n        }\r\n        return this.entries.delete(key);\r\n    }\r\n\r\n    /**\r\n     * Adds items to the store and updated any associated indexes\r\n     * @param  {Array<any>} items items to add\r\n     */\r\n    add(items) {\r\n        items = mem.oneOrMany(items);\r\n        items.map(item => this.updateOne(item));\r\n    }\r\n\r\n    /**\r\n     * Adds an item to the store and updated any associated indexes\r\n     * @param  {any} item item to add\r\n     */\r\n    addOne(item) {\r\n        this.updateOne(item);\r\n    }\r\n\r\n    /**\r\n     * Updates items to the store and updated any associated indexes\r\n     * @param  {Array<any>} items items to update\r\n     */\r\n    update(items) {\r\n        items = mem.oneOrMany(items);\r\n        items.forEach(item => {\r\n            this.updateOne(item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates an item in the store and updated any associated indexes\r\n     * @param  {any} item item to update\r\n     */\r\n    updateOne(item) {\r\n        let old;\r\n        const key = this.keyFn(item);\r\n        if (this.entries.has(key)) {\r\n            old = this.entries.get(key);\r\n        }\r\n        if (this.indexes.size > 0) {\r\n            this.indexes.forEach(index => index.update(item, old));\r\n        }\r\n        this.entries.set(key, item);\r\n    }\r\n}","import * as mem from '../common';\r\n\r\n/**\r\n * Base index for use with in-memory-store\r\n */\r\nexport class BaseIndex {\r\n    /**\r\n     * @param  {string} name name of this index\r\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\r\n     * @param  {itemCallback} itemFn function to call to get the unique item key of the items in this index\r\n     */\r\n    constructor (name, itemFn, keyFn) {\r\n        if (this.constructor === BaseIndex) {\r\n            throw new TypeError(\"Cannot construct BaseIndex directly\");\r\n        }\r\n\r\n        this.name = name;\r\n        this.itemFn = itemFn;\r\n        this.keyFn = keyFn;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not this index is empty\r\n     * @abstract\r\n     * @return {boolean}\r\n     */\r\n    get isEmpty() {\r\n        throw new TypeError(`Must implement isEmpty property`);\r\n    }\r\n\r\n    /**\r\n     * Returns all keys\r\n     * @abstract\r\n     * @return {Array<Key>}\r\n     */\r\n    get keys() {\r\n        throw new TypeError(`Must implement keys property`);\r\n    }    \r\n\r\n    /**\r\n     * Removes all items from the index\r\n     * @abstract\r\n     */\r\n    clear() {\r\n        throw new TypeError(`Must implement clear method`);\r\n    }\r\n\r\n    /**\r\n     * Returns items within matching passed index keys\r\n     * @param  {Array<any>} keys specified index keys\r\n     * @return {Array<any>} values found\r\n     */\r\n    findMany(keys) {\r\n        keys = mem.oneOrMany(keys);\r\n        let data = keys.map(m => this.find(m));\r\n        return [].concat.apply([], data);\r\n    }\r\n\r\n    /**\r\n     * Returns items matching passed index key\r\n     * @abstract\r\n     * @param  {any} key specified index key\r\n     * @return {Array<any>} values found\r\n     */\r\n    find(key) {\r\n        throw new TypeError(`Must implement find method`);\r\n    }\r\n\r\n    /**\r\n     * Removes an item\r\n     * @abstract\r\n     * @param  {any} item item to remove\r\n     */\r\n    remove(item) {\r\n        throw new TypeError(`Must implement build method`);\r\n    }\r\n\r\n    /**\r\n     * Populates this index with new items and indexes as per itemFn and keyFn defined on index creation\r\n     * @param  {Array<any>} items items to populate store with\r\n     */\r\n    populate(items) {\r\n        if (!this.isEmpty) {\r\n            throw new Error(`${typeof this} index must be empty in order to use populate`);\r\n        }\r\n\r\n        items = mem.oneOrMany(items);\r\n        items.forEach(item => this.insert(item));\r\n    }\r\n\r\n    /**\r\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\r\n     * @abstract\r\n     * @param  {any} item item to add to index\r\n     */\r\n    insert(item) {\r\n        throw new TypeError(`Must implement insert method`);\r\n    }\r\n\r\n    /**\r\n     * Updates an item by removing any associated index entry based on oldItem and adding new index\r\n     * entries based on the new item.  Important to pass oldItem otherwise index may contain entries from\r\n     * item in wrong indexed key.\r\n     * @param  {any} oldItem item as it was prior to being updated\r\n     * @param  {any} item item as it is now\r\n     */\r\n    update(item, olditem) {\r\n        this.remove(olditem);\r\n        this.insert(item);\r\n    }\r\n}","import * as mem from '../common';\r\nimport { BaseIndex } from './baseindex';\r\n\r\n/**\r\n * Index based on javascript Map object for key/value storage. Groups items by index value, \r\n * stores items within index value as array using linear search.\r\n * @extends {BaseIndex}\r\n */\r\nexport class HashIndex extends BaseIndex {\r\n    /**\r\n     * @param  {string} name name of this index\r\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\r\n     * @param  {itemCallback} itemFn function to call to get the unique item key of the items in this index\r\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one index value to another\r\n     */\r\n    constructor (name, itemFn, keyFn, comparer) {\r\n        this.comparer = comparer || mem.defaultComparer;\r\n        this.index = new Map([]);\r\n        super(name, itemFn, keyFn);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not this index is empty\r\n     * @abstract\r\n     * @return {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return this.index.size === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns all keys\r\n     * @return {Array<Key>}\r\n     */\r\n    get keys() {\r\n        return Array.from(this.index.keys());\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less than the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lt(key) {\r\n        let keys = this.keys.filter(k => {\r\n            return mem.lt(this.comparer, k, key);\r\n        });\r\n        return this.findMany(keys);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lte(key) {\r\n        let keys = this.keys.filter(k => {\r\n            return mem.lte(this.comparer, k, key);\r\n        });\r\n        return this.findMany(keys);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gt(key) {\r\n        let keys = this.keys.filter(k => {\r\n            return mem.gt(this.comparer, k, key);\r\n        });\r\n        return this.findMany(keys);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gte(key) {\r\n        let keys = this.keys.filter(k => {\r\n            return mem.gte(this.comparer, k, key);\r\n        });\r\n        return this.findMany(keys);\r\n    }\r\n\r\n    /**\r\n     * Removes all items from the index\r\n     */\r\n    clear() {\r\n        this.index = new Map([]);\r\n    }\r\n\r\n    /**\r\n     * Returns items matching passed index key\r\n     * @param  {any} key specified index key\r\n     * @return {Array<any>} values found\r\n     */\r\n    find(key) {\r\n        return this.index.get(key);\r\n    }\r\n\r\n    /**\r\n     * Removes an item\r\n     * @param  {any} item item to remove\r\n     */\r\n    remove(item) {\r\n        const key = this.keyFn(item);\r\n        if (this.index.has(key)) {\r\n            const col = this.index.get(key);\r\n            const it = this.itemFn(item);\r\n            const i = col.indexOf(it);\r\n            if (i > -1) {\r\n                col.splice(i, 1);\r\n            }\r\n            if (col.length === 0) {\r\n                this.index.delete(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\r\n     * @param  {any} item item to add to index\r\n     */\r\n    insert(item) {\r\n        const key = this.keyFn(item);\r\n        const it = this.itemFn(item);\r\n        if (it && key) {\r\n            if (this.index.has(key)) {\r\n                this.index.get(key).push(it);\r\n            } else {\r\n                this.index.set(key, [it]);\r\n            }\r\n        }\r\n    }\r\n}","import * as mem from '../common';\r\n\r\n/**\r\n * Binary key/value storage backed by native javascript array. Performs binary search on entries and\r\n * keeps items in sorted order based on comparer.\r\n */\r\nexport class BinaryArray {\r\n    /**\r\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one index value to another\r\n     */\r\n    constructor (comparer) {\r\n        this.arr = [];\r\n        this.comparer = comparer || mem.defaultComparer;\r\n    }\r\n    \r\n    /**\r\n     * Removes all items from the index\r\n     */\r\n    clear() {\r\n        this.arr = [];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of keys store in this Key Value array\r\n     * @returns {Array<any>} all keys\r\n     */\r\n    get keys() {\r\n        return this.arr.map(m => m.key);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of items in this BinaryArray\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return this.arr.length;\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less than the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lt(key) {\r\n        let i = this.insertPos(key);\r\n        let data = this.arr.slice(0, i);\r\n        return data.map(d => d.value);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lte(key) {\r\n        let i = this.insertPos(key);\r\n        let data = i >= 0 ? this.arr.slice(0, i + 1) : [];\r\n        return data.map(d => d.value);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gt(key) {\r\n        let i = this.insertPos(key);\r\n        let data = i < this.arr.length ? this.arr.slice(i + 1, this.arr.length) : [];\r\n        return data;\r\n        return data.map(d => d.value);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gte(key) {\r\n        let i = this.insertPos(key);\r\n        let data = i < this.arr.length ? this.arr.slice(i, this.arr.length) : [];\r\n        return data.map(d => d.value);\r\n    }\r\n\r\n    /**\r\n     * Returns the index in this array of the specified key\r\n     * @param {any} key \r\n     * @returns {number}\r\n     */\r\n    indexOf(key) {\r\n        let i = this.insertPos(key);\r\n        if (this.arr[i] && mem.eq(this.comparer, this.arr[i].key, key)) {\r\n            return i;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The insert position where to insert an item into the underlying sorted array.     \r\n     * @param {any} key key to find in the array\r\n     * @returns {number} position at which a new item should be inserted into this array\r\n     */\r\n    insertPos(key) {\r\n        let low = 0, high = this.arr.length, mid;\r\n        while (low < high) {\r\n            // faster version of Math.floor((low + high) / 2)\r\n            mid = (low + high) >>> 1; \r\n            mem.lt(this.comparer, this.arr[mid].key, key) ? low = mid + 1 : high = mid\r\n        }\r\n        return low;\r\n    }\r\n\r\n    /**\r\n     * Returns items matching passed index key\r\n     * @param  {any} key specified index key\r\n     * @return {Array<any>} values found\r\n     */\r\n    get(key) {\r\n        const i = this.indexOf(key);\r\n        if (i > -1) {\r\n            return this.arr[i].value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes an item by key\r\n     * @param  {any} key key of item to remove\r\n     */\r\n    remove(key) {\r\n        const i = this.indexOf(key);\r\n        if (i > -1) {\r\n            this.removeAt(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an key/value with array\r\n     * @param  {any} key key to add\r\n     * @param  {any} value item related to the specified key\r\n     */\r\n    add(key, value) {\r\n        const ix = this.insertPos(key);\r\n        let item = { key: key, value: value };\r\n        this.addAt(ix, key, value);\r\n    }\r\n\r\n    /**\r\n     * Adds a key/value entry at a specified position in the array.\r\n     * Will not replace any existing item in that postion, instead\r\n     * inserting before it.\r\n     * @param {number} pos index of where to add this entry\r\n     * @param {any} key key to add\r\n     * @param {any} value item related to the specified key\r\n     */\r\n    addAt(pos, key, value) {\r\n        let item = { key: key, value: value };\r\n        this.arr.splice(pos, 0, item);\r\n    }\r\n\r\n    /**\r\n     * Removes a key/value entry at a specified position\r\n     * @param {number} pos index of the item to remove.\r\n     */\r\n    removeAt(pos) {\r\n        this.arr.splice(pos, 1);\r\n    }\r\n\r\n    /**\r\n     * Returns key matching passed index position\r\n     * @param  {number} pos index of where to add this entry\r\n     * @return {any} key found at this position\r\n     */\r\n    getAt(pos) {\r\n        return this.arr[pos];\r\n    }\r\n}","import * as mem from '../common';\r\nimport { BinaryArray } from './binaryarray';\r\nimport { BaseIndex } from './baseindex';\r\n\r\n/**\r\n * Index based on BinaryArray for key/value storage. Groups items by index value, \r\n * stores items within index value as array using linear search.\r\n * @extends {BaseIndex}\r\n */\r\nexport class BinaryIndex extends BaseIndex {\r\n    /**\r\n     * @implements {BaseIndex}\r\n     * @param  {string} name name of this index\r\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\r\n     * @param  {itemCallback} itemFn function to call to get the unique item key of the items in this index\r\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one index value to another\r\n     */\r\n    constructor (name, itemFn, keyFn, comparer) {\r\n        this.comparer = comparer || mem.defaultComparer;\r\n        this.index = new BinaryArray(this.comparer);\r\n        super(name, itemFn, keyFn);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not this index is empty\r\n     * @abstract\r\n     * @return {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return this.index.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns all keys\r\n     * @return {Array<Key>}\r\n     */\r\n    get keys() {\r\n        return this.index.keys;\r\n    }\r\n\r\n    /**\r\n     * Removes all items from the index\r\n     */\r\n    clear() {\r\n        this.index = new BinaryArray(this.comparer);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less than the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lt(key) {\r\n        return this.index.lt(key);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lte(key) {\r\n        return this.index.lte(key);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gt(key) {\r\n        return this.index.gt(key);\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gte(key) {\r\n        return this.index.gte(key);\r\n    }\r\n\r\n    /**\r\n     * Returns items matching passed index key\r\n     * @param  {any} key specified index key\r\n     * @return {Array<any>} values found\r\n     */\r\n    find(key) {\r\n        return this.index.get(key);\r\n    }\r\n\r\n    /**\r\n     * Removes an item\r\n     * @param  {any} item item to remove\r\n     */\r\n    remove(item) {\r\n        const key = this.keyFn(item);\r\n        const pos = this.index.indexOf(key);\r\n        \r\n        if (pos > -1) {\r\n            const entry = this.index.getAt(pos);\r\n            const it = this.itemFn(item);\r\n            const i = entry.value.indexOf(it);\r\n            if (i > -1) {\r\n                entry.value.splice(i, 1);\r\n            }\r\n            if (entry.value.length === 0) {\r\n                this.index.removeAt(pos);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\r\n     * @param  {any} item item to add to index\r\n     */\r\n    insert(item) {\r\n        const key = this.keyFn(item);\r\n        const it = this.itemFn(item);\r\n        const pos = this.index.insertPos(key);\r\n        const entry = this.index.getAt(pos);\r\n        \r\n        if (entry && mem.eq(this.comparer, entry.key, key)) {\r\n            entry.value.push(it);\r\n        } else {\r\n            this.index.addAt(pos, key, [it]); \r\n        }\r\n    }\r\n}","import * as mem from '../common';\r\nimport AVLTree from 'avl';\r\nimport { BaseIndex } from './baseindex';\r\n\r\n/**\r\n * Index based on AVL Tree object for key/value storage. Groups items by index value, \r\n * stores items within index value as array using linear search.\r\n * @extends {BaseIndex}\r\n */\r\nexport class AVLIndex extends BaseIndex {\r\n    /**\r\n     * @param  {string} name name of this index\r\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\r\n     * @param  {itemCallback} itemFn function to call to get the unique item key of the items in this index\r\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one index value to another\r\n     */\r\n    constructor (name, itemFn, keyFn, comparer) {\r\n        this.comparer = comparer || mem.defaultComparer;\r\n        this.index = new AVLTree(comparer);\r\n        super(name, itemFn, keyFn);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not this index is empty\r\n     * @abstract\r\n     * @return {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return this.index.size === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns all keys\r\n     * @return {Array<Key>}\r\n     */\r\n    get keys() {\r\n        return this.index.keys();\r\n    }\r\n\r\n    /**\r\n     * Removes all items from the index\r\n     */\r\n    clear() {\r\n        this.index.clear();\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less than the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lt(key) {\r\n        let lastKey;\r\n        let data = [];\r\n        this.index.range(this.index.min, key, n => {\r\n            lastKey = n.key;\r\n            data.push(n.data);\r\n        });\r\n        if (data.length === 0) {\r\n            return [];\r\n        }\r\n        // Since Tree is unique, we only need to check last key to omit\r\n        if (mem.eq(this.comparer, lastKey, key)) {\r\n            data.pop();\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns all entries less or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    lte(key) {\r\n        let data = [];\r\n        this.index.range(this.index.min, key, n => {\r\n            data.push(n.data);\r\n        });\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gt(key) {\r\n        let firstKey;\r\n        let data = [];\r\n        this.index.range(key, this.index.max, n => {\r\n            if (firstKey === undefined) {\r\n                firstKey = n.key;\r\n            }\r\n            data.push(n.data);\r\n        });\r\n        if (data.length === 0) {\r\n            return [];\r\n        }\r\n        // Since Tree is unique, we only need to check first key to omit\r\n        if (mem.eq(this.comparer, firstKey, key)) {\r\n            data.shift();\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns all entries greater than or equal to the passed key according to the\r\n     * indexes comparer.\r\n     * @param {any} key \r\n     */\r\n    gte(key) {\r\n        let data = [];\r\n        this.index.range(key, this.index.max, n => {\r\n            data.push(n.data);\r\n        });\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns items matching passed index key\r\n     * @param  {any} key specified index key\r\n     * @return {Array<any>} values found\r\n     */\r\n    find(key) {\r\n        let found = this.index.find(key);\r\n        if (found) {\r\n            return found.data;\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes an item\r\n     * @param  {any} item item to remove\r\n     */\r\n    remove(item) {\r\n        const key = this.keyFn(item);\r\n        const entry = this.index.find(key);\r\n\r\n        if (entry) {\r\n            const it = this.itemFn(item);\r\n            const arr = entry.data;\r\n            const i = arr.indexOf(it);\r\n            if (i > -1) {\r\n                arr.splice(i, 1);\r\n            }\r\n            if (arr.length === 0) {\r\n                this.index.remove(key);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\r\n     * @param  {any} item item to add to index\r\n     */\r\n    insert(item) {\r\n        const key = this.keyFn(item);\r\n        const it = this.itemFn(item);\r\n        const entry = this.index.find(key);\r\n        \r\n        if (entry) {\r\n            entry.data.push(it);\r\n        } else {\r\n            this.index.insert(key, [it]);\r\n        }\r\n    }\r\n}"],"names":["const","let","mem.oneOrMany","this","mem.extract","mem.intersect","prototypeAccessors","mem.defaultComparer","super","mem.lt","mem.lte","mem.gt","mem.gte","mem.eq"],"mappings":"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"}