{"version":3,"file":"in-memory-store.js","sources":["../src/common.js","../src/find.js","../src/in-memory-store.js","../src/indexes/baseindex.js","../src/indexes/hashindex.js","../src/indexes/binaryarray.js","../src/indexes/binaryindex.js","../src/indexes/avlindex.js"],"sourcesContent":["/**\n* Callback for comparer\n* @callback comparerCallback\n* @param   {Key} a\n* @param   {Key} b\n* @returns {number} -1 if a < b, 0 if a === b, 1 if a > b\n*/\n\n/**\n * Callback for item identifier\n * @callback itemCallback\n * @param   {any} item\n * @returns {any} unique value to identify the item\n */\n\n/**\n * Callback for key value\n * @callback keyCallback\n * @param   {any} item\n * @returns {any} value to index this item on\n */\n\n/**\n * Converts a passed value into an array.  Useful if you don't know\n * if your passed parameter is an array or single value.\n * @param  {any} items single item, array or javascript Map object\n * @return {Array<any>} array of passed item(s)\n */\nexport function oneOrMany(items) {\n  if (!items) {\n    return [];\n  } if (items instanceof Map) {\n    return Array.from(items.values());\n  } if (!Array.isArray(items)) {\n    return [items];\n  }\n  return items;\n}\n\n/**\n * Returns whether or not a < b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a <= b\n */\nexport function lte(comparer, a, b) {\n  return comparer(a, b) <= 0;\n}\n\n/**\n * Returns whether or not a > b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a => b\n */\nexport function gte(comparer, a, b) {\n  return comparer(a, b) >= 0;\n}\n\n/**\n * Returns whether or not a < b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a < b\n */\nexport function lt(comparer, a, b) {\n  return comparer(a, b) < 0;\n}\n\n/**\n * Returns whether or not a > b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a > b\n */\nexport function gt(comparer, a, b) {\n  return comparer(a, b) > 0;\n}\n\n/**\n * Returns whether or not a === b\n * @param  {comparerCallback} comparer comparer to use\n * @param  {any} a\n * @param  {any} b\n * @return {boolean} whether or not a === b\n */\nexport function eq(comparer, a, b) {\n  return comparer(a, b) === 0;\n}\n\n/**\n * Default comparer equal to as used on Array.sort\n * @param  {any} a\n * @param  {any} b\n * @return {number} result of comparison\n */\nexport function defaultComparer(a, b) {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * Wraps any comparer with a call to .key on both a and b.\n * Useful if you comparer is a value comparer but the values\n * are objects with keys to compare.\n * @param  {comparerCallback} comparer comparer to use\n * @return {comparerCallback} comparer wrapped in .key calls\n */\nexport function keyWrapComparer(comparer) {\n  return (a, b) => comparer(a.key, b.key);\n}\n\n/**\n * Intersects N arrays\n * @param  {Array<Array<any>>} arrays N arrays with values to intersect\n * @return {Array<any>} array of values where that value is in all array\n */\nexport function intersect(arrays) {\n  const ordered = (arrays.length === 1\n    ? arrays\n    : arrays.sort((a1, a2) => a1.length - a2.length));\n  const shortest = ordered[0];\n  const set = new Set();\n  const result = [];\n\n  for (let i = 0; i < shortest.length; i += 1) {\n    const item = shortest[i];\n    let every = true; // don't use ordered.every ... it is slow\n    for (let j = 1; j < ordered.length; j += 1) {\n      if (!ordered[j].includes(item)) {\n        every = false;\n        break;\n      }\n    }\n    // ignore if not in every other array, or if already captured\n    if (every || !set.has(item)) {\n      // otherwise, add to book keeping set and the result\n      set.add(item);\n      result[result.length] = item;\n    }\n  }\n  return result;\n}\n\n/**\n * Extracts items passed by an array of keys from the passed map.\n * @param  {Map} map javascript map object containing all keys and values\n * @param  {Array<any>} keys keys to extract from the map\n * @return {Array<any>} array of values extracted from the passed map\n */\nexport function extract(map, keys) {\n  const r = [];\n  const manyKeys = oneOrMany(keys);\n  const defMap = map || new Map([]);\n\n  manyKeys.forEach((key) => {\n    if (map.has(key)) {\n      r.push(defMap.get(key));\n    }\n  });\n  return r;\n}\n\n/**\n * Flattens an array one level deep.\n * @param  {Array<any>} arr array of arrays to flatten\n * @return {Array<any>} flattened array\n */\nexport function shallowFlat(arr) {\n  const resultArr = [];\n  if (!arr) {\n    return resultArr;\n  }\n  for (let i = 0; i < arr.length; i += 1) {\n    resultArr.push(...arr[i]);\n  }\n  return resultArr;\n}\n","import * as mem from './common';\n\n/**\n * Key value storage with support for grouping/returning items by index value\n */\nexport default class Find {\n  /**\n     * @param {Map<indexName, index>} indexes Map of indexes to query\n     */\n  constructor(indexes) {\n    this.indexes = indexes;\n  }\n\n  /**\n     * Searches one or many indexes, each using specified operator for specified value.\n     * @param {Array<any>} filters [{\"indexName\":{\"operator\":\"value\"}},\n     * {\"indexName\":{\"operator\":\"value\"}}]\n     * @returns {Array<any>} keys found in all passed index searches\n     */\n  $and(filters) {\n    const filterFns = this.getFilterFns(filters, this.indexes);\n    const dataSets = filterFns.map(fn => fn());\n    return mem.intersect(dataSets);\n  }\n\n  /**\n     * Searches one or many indexes, each using specified operator for specified value.\n     * @param {Array<any>} filters [{\"indexName\":{\"operator\":\"value\"}},\n     * {\"indexName\":{\"operator\":\"value\"}}]\n     * @returns {Array<any>} keys found in all passed index searches\n     */\n  $or(filters) {\n    const filterFns = this.getFilterFns(filters, this.indexes);\n    const dataSets = filterFns.map(fn => fn());\n    return dataSets.reduce((a, b) => a.concat(b), []);\n  }\n\n  /**\n     * Performs a find across many indexes based on limited find selector language.\n     * @param {Array<any>} selector\n     * { $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     * @returns {Array<any>} keys from found in all passed index searches\n     */\n  find(query) {\n    const selector = Find.parseQuery(query);\n    const joins = Object.keys(selector);\n    const fns = joins.map(op => this.combinatorFn(op, selector[op]));\n    const dataSets = fns.map(fn => fn());\n    // All operator results are ultimately $and together\n    return mem.intersect(dataSets);\n  }\n\n  /**\n     * Gets the combinator function based on the specified combinator key.\n     * @param {*} key Either $and or $or\n     * @param {*} filters The filters to pass through to the combinator.\n     */\n  combinatorFn(key, filters) {\n    switch (key) {\n      case '$and':\n        return () => this.$and(filters);\n      case '$or':\n        return () => this.$or(filters);\n      default:\n        return () => this.$and(filters);\n    }\n  }\n\n  /**\n     * Gets a filter function based on the specified operator key..\n     * @param {string} operator $lt/$gt/$gte/$lte or $eq\n     * @returns {any} function coresponding to passed key\n     */\n  static opertatorFn(key, index, val) {\n    switch (key) {\n      case '$lt':\n        return () => index.$lt(val);\n      case '$lte':\n        return () => index.$lte(val);\n      case '$gt':\n        return () => index.$gt(val);\n      case '$gte':\n        return () => index.$gte(val);\n      case '$in':\n        return () => index.$in(val);\n      case '$eq':\n        return () => index.$eq(val);\n      default:\n        return () => index.$eq(val);\n    }\n  }\n\n  /**\n     * Parses loose query language to strict with implicit operators and combinators\n     * made explicit.\n     * @param {*} query Query to parse in following supported formats...\n     * { $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     * OR (implicit $and)\n     * [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}]\n     * OR (implicit $eq)\n     * {\"indexName\":\"value\", \"indexName\":\"value\"}\n     * OR (implicit $in)\n     * {\"indexName\":\"value\", \"indexName\":[\"value1\", \"value1\"]}\n     * @returns {object} Strict query format in format...\n     * { $and: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     */\n  static parseQuery(query) {\n    const selector = {};\n    if (typeof query === 'object') {\n      const keys = Object.keys(query);\n\n      if (Array.isArray(query) || !Array.isArray(query[keys[0]])) {\n        // We've got a single item or array of items\n        selector.$and = [];\n        Find.parseInnerSelector(query, selector.$and);\n      } else {\n        // We've got a combinator\n        keys.forEach((key) => {\n          selector[key] = [];\n          Find.parseInnerSelector(query[key], selector[key]);\n        });\n      }\n    } else {\n      throw new SyntaxError(`Query should be an object or an array ${JSON.stringify(query)}`);\n    }\n    return selector;\n  }\n\n  static parseInnerSelector(query, selectors) {\n    // Inner selector should be an array\n    let manyQueries = query;\n    if (!Array.isArray(query)) {\n      manyQueries = [query];\n    }\n\n    const converted = manyQueries.map((part) => {\n      const selector = {};\n      if (typeof part !== 'object') {\n        throw new SyntaxError(`Selector part should be an object ${JSON.stringify(part)}`);\n      }\n\n      Object.keys(part).forEach((k) => {\n        // First part is always an index name (i.e. field name)\n        selector[k] = {};\n\n        // If it's an object, we've got an operator/key combination\n        // otherwise it's just a value\n        if (Array.isArray(part[k])) {\n          selector[k].$in = part[k];\n        } else if (typeof part[k] === 'object') {\n          const op = Object.keys(part[k])[0];\n          selector[k][op] = part[k][op];\n        } else {\n          selector[k].$eq = part[k];\n        }\n      });\n      return selector;\n    });\n\n    selectors.push(...converted);\n  }\n\n  /**\n     * Get function array based on specified find criteria.\n     * @param {Array<any>} filters [{\"indexName\":{\"operator\":\"value\"}},\n     * {\"indexName\":{\"operator\":\"value\"}}]\n     * @returns {Array<any>} Array of functions to perform specified find operations.\n     */\n  getFilterFns(filters) {\n    const manyFilters = mem.oneOrMany(filters);\n    return manyFilters.map((f) => {\n      // only one entry per filter\n      const filter = Object.entries(f)[0];\n      const indexName = filter[0];\n      const action = filter[1];\n\n      if (typeof action !== 'object') {\n        throw new TypeError(`Filter must contain a valid action object, passed filter ${filter}`);\n      }\n\n      const op = Object.keys(action)[0];\n      const val = action[op];\n\n      if (!this.indexes.has(indexName)) {\n        throw new TypeError(`Invalid index specified ${indexName}`);\n      }\n\n      return Find.opertatorFn(op, this.indexes.get(indexName), val);\n    });\n  }\n}\n","import * as mem from './common';\nimport Find from './find';\n\n/**\n * Key value storage with support for grouping/returning items by index value\n */\nexport default class InMemoryStore {\n  /**\n    * @param  {keyCallback} [keyFn] function to call to get the key of the items in this store\n    */\n  constructor(keyFn) {\n    this.indexes = new Map([]);\n    this.entries = new Map([]);\n    this.finder = new Find(this.indexes);\n    this.keyFn = keyFn;\n  }\n\n  /**\n     * Returns whether the store is empty\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.entries.size === 0;\n  }\n\n  /**\n     * Returns the number of items in the store\n     * @return {number}\n     */\n  get size() {\n    return this.entries.size;\n  }\n\n  /**\n     * Gets an index from the store by name.\n     * @param {string} name name of the index to get\n     * @returns {BaseIndex} index found\n     */\n  index(name) {\n    if (!this.indexes.has(name)) {\n      throw new Error(`Index ${name} not found in store`);\n    }\n    return this.indexes.get(name);\n  }\n\n  /**\n     * Returns all keys wihin the specified index\n     * @return {Array<Key>}\n     */\n  getIndexKeys(indexName) {\n    return this.indexes.get(indexName).keys;\n  }\n\n  /**\n     * Populates a new store with items using bulk load methods for indexes if available\n     * @param  {Array<any>} items items to populate store with\n     */\n  populate(items) {\n    if (!this.isEmpty) {\n      throw new Error(`Store must be empty to use populate. \n                Store currently has ${this.size} items.`);\n    }\n\n    const manyItems = mem.oneOrMany(items);\n    this.indexes.forEach(index => index.populate(manyItems));\n    const data = manyItems.map(item => [this.keyFn(item), item]);\n    this.entries = new Map(data);\n  }\n\n  /**\n     * Clears and re-populates a new store with items using bulk\n     * load methods for indexes if available\n     * @param  {Array<any>} items items to populate store with\n     */\n  rebuild(items) {\n    this.entries = new Map([]);\n    this.indexes.forEach(index => index.clear());\n    this.populate(items);\n  }\n\n  /**\n     * Clear the store\n     * @return {InMemoryStore}\n     */\n  destroy() {\n    this.indexes = new Map([]);\n    this.entries = new Map([]);\n    this.keyFn = undefined;\n  }\n\n  /**\n     * Whether the store contains an item with the given key\n     * @param  {Key} key\n     * @return {boolean} true/false\n     */\n  has(item) {\n    return this.entries.has(this.keyFn(item));\n  }\n\n  /**\n     * Performs a find across many indexes based on limited find selector language.\n     * @param {Array<any>} selector\n     * { $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}],\n     * $or: [{\"indexName\":{\"operator\":\"value\"}}, {\"indexName\":{\"operator\":\"value\"}}] }\n     * @returns {Array<any>} items from the store found in all passed index searches\n     */\n  find(query) {\n    const data = this.finder.find(query);\n    return mem.extract(this.entries, data);\n  }\n\n  /**\n     * Returns items within specified index matching passed values\n     * @param  {string} indexName index to search\n     * @param  {Array<any>} values specified index values\n     * @return {Array<any>} values found\n     */\n  get(indexName, values) {\n    const data = this.indexes.has(indexName)\n      ? this.indexes.get(indexName).findMany(values) : [];\n    return mem.extract(this.entries, data);\n  }\n\n  /**\n     * Returns items within specified index matching passed value\n     * @param  {string} indexName index to search\n     * @param  {any} value specified index value\n     * @return {Array<any>} values found\n     */\n  getOne(indexName, value) {\n    const data = this.indexes.has(indexName)\n      ? this.indexes.get(indexName).find(value) : [];\n    return mem.extract(this.entries, data);\n  }\n\n  /**\n     * Adds a new index onto this store if it does not already exist. Populates index with entries\n     * if index not already populated.\n     * @param  {BaseIndex} index index ensure exists and is populated\n     * @return {boolean} true if index was added by this operation, false if already exists.\n     */\n  ensureIndex(index) {\n    if (!this.indexes.has(index.name)) {\n      this.indexes.set(index.name, index);\n      if (index.isEmpty) {\n        index.populate(this.entries);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n     * Removes items from the store and any associated indexes\n     * @param  {Array<any>} items items to remove\n     * @return {Array<boolean>} whether each remove succeeded (false if not found)\n     */\n  remove(items) {\n    const manyItems = mem.oneOrMany(items);\n    return manyItems.map(item => this.removeOne(item));\n  }\n\n  /**\n     * Removes an item from the store and any associated indexes\n     * @param  {any} item item to remove\n     * @return {boolean} whether remove succeeded (false if not found)\n     */\n  removeOne(item) {\n    if (this.indexes.size > 0) {\n      this.indexes.forEach(index => index.remove(item));\n    }\n    return this.entries.delete(this.keyFn(item));\n  }\n\n  /**\n     * Removes an item from the store by key and any associated indexes\n     * @param  {any} key key of item to remove\n     * @return {boolean} whether remove succeeded (false if not found)\n     */\n  removeKey(key) {\n    const item = this.entries.get(key);\n    if (!item) {\n      return false;\n    }\n    if (this.indexes.size > 0) {\n      this.indexes.forEach(index => index.remove(item));\n    }\n    return this.entries.delete(key);\n  }\n\n  /**\n     * Adds items to the store and updated any associated indexes\n     * @param  {Array<any>} items items to add\n     */\n  add(items) {\n    const manyItems = mem.oneOrMany(items);\n    manyItems.map(item => this.updateOne(item));\n  }\n\n  /**\n     * Adds an item to the store and updated any associated indexes\n     * @param  {any} item item to add\n     */\n  addOne(item) {\n    this.updateOne(item);\n  }\n\n  /**\n     * Updates items to the store and updated any associated indexes\n     * @param  {Array<any>} items items to update\n     */\n  update(items) {\n    const manyItems = mem.oneOrMany(items);\n    manyItems.forEach((item) => {\n      this.updateOne(item);\n    });\n  }\n\n  /**\n     * Updates an item in the store and updated any associated indexes\n     * @param  {any} item item to update\n     */\n  updateOne(item) {\n    let old;\n    const key = this.keyFn(item);\n    if (this.entries.has(key)) {\n      old = this.entries.get(key);\n    }\n    if (this.indexes.size > 0) {\n      this.indexes.forEach(index => index.update(item, old));\n    }\n    this.entries.set(key, item);\n  }\n}\n","/* eslint class-methods-use-this: 0 */\nimport * as mem from '../common';\n\n/**\n * Base index for use with in-memory-store\n */\nexport default class BaseIndex {\n  /**\n     * @param  {string} name name of this index\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\n     * @param  {itemCallback} itemFn function to call to get the unique item key of the\n     * items in this index\n     */\n  constructor(name, itemFn, keyFn) {\n    if (this.constructor === BaseIndex) {\n      throw new TypeError('Cannot construct BaseIndex directly');\n    }\n\n    this.name = name;\n    this.itemFn = itemFn;\n    this.keyFn = keyFn;\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    throw new TypeError('Must implement isEmpty property');\n  }\n\n  /**\n     * Returns all keys\n     * @abstract\n     * @return {Array<Key>}\n     */\n  get keys() {\n    throw new TypeError('Must implement keys property');\n  }\n\n  /**\n     * Removes all items from the index\n     * @abstract\n     */\n  clear() {\n    throw new TypeError('Must implement clear method');\n  }\n\n  /**\n     * Returns items within matching passed index keys\n     * @param  {Array<any>} keys specified index keys\n     * @return {Array<any>} values found\n     */\n  findMany(keys) {\n    const manyKeys = mem.oneOrMany(keys);\n    const data = manyKeys.map(m => this.find(m));\n    return [].concat(...data);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @abstract\n     * @return {Array<any>} values found\n     */\n  find() {\n    throw new TypeError('Must implement find method');\n  }\n\n  /**\n     * Removes an item\n     * @abstract\n     */\n  remove() {\n    throw new TypeError('Must implement build method');\n  }\n\n  /**\n     * Populates this index with new items and indexes\n     * as per itemFn and keyFn defined on index creation\n     * @param  {Array<any>} items items to populate store with\n     */\n  populate(items) {\n    if (!this.isEmpty) {\n      throw new Error(`${typeof this} index must be empty in order to use populate`);\n    }\n\n    const manyItems = mem.oneOrMany(items);\n    manyItems.forEach(item => this.insert(item));\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @abstract\n     */\n  insert() {\n    throw new TypeError('Must implement insert method');\n  }\n\n  /**\n     * Updates an item by removing any associated index entry based on oldItem and adding new index\n     * entries based on the new item.  Important to pass oldItem otherwise index\n     * may contain entries from item in wrong indexed key.\n     * @param  {any} oldItem item as it was prior to being updated\n     * @param  {any} item item as it is now\n     */\n  update(item, olditem) {\n    if (olditem) {\n      this.remove(olditem);\n    }\n    this.insert(item);\n  }\n}\n","import * as mem from '../common';\nimport BaseIndex from './baseindex';\n\n/**\n * Index based on javascript Map object for key/value storage. Groups items by index value,\n * stores items within index value as array using linear search.\n * @extends {BaseIndex}\n */\nexport default class HashIndex extends BaseIndex {\n  /**\n     * @param  {string} name name of this index\n     * @param  {itemCallback} itemFn function to call to get the unique item key\n     * of the items in this index\n     * @param  {keyCallback} keyFn function to call to get the index key of the\n     * items in this index\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one\n     * index value to another\n     */\n  constructor(name, itemFn, keyFn, comparer) {\n    super(name, itemFn, keyFn);\n    this.comparer = comparer || mem.defaultComparer;\n    this.index = new Map([]);\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.index.size === 0;\n  }\n\n  /**\n     * Returns all keys\n     * @return {Array<Key>}\n     */\n  get keys() {\n    return Array.from(this.index.keys());\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lt(key) {\n    const keys = this.keys.filter(k => mem.lt(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lte(key) {\n    const keys = this.keys.filter(k => mem.lte(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns all entries greater than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gt(key) {\n    const keys = this.keys.filter(k => mem.gt(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gte(key) {\n    const keys = this.keys.filter(k => mem.gte(this.comparer, k, key));\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  $eq(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Returns items matching passed index keys\n     * @param  {Array<any>} key specified index keys\n     * @return {Array<any>} values found\n     */\n  $in(keys) {\n    return this.findMany(keys);\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.index = new Map([]);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  find(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Removes an item\n     * @param  {any} item item to remove\n     */\n  remove(item) {\n    const key = this.keyFn(item);\n    if (this.index.has(key)) {\n      const col = this.index.get(key);\n      const it = this.itemFn(item);\n      const i = col.indexOf(it);\n      if (i > -1) {\n        col.splice(i, 1);\n      }\n      if (col.length === 0) {\n        this.index.delete(key);\n      }\n    }\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @param  {any} item item to add to index\n     */\n  insert(item) {\n    const key = this.keyFn(item);\n    const it = this.itemFn(item);\n    if (it && key) {\n      if (this.index.has(key)) {\n        this.index.get(key).push(it);\n      } else {\n        this.index.set(key, [it]);\n      }\n    }\n  }\n}\n","import * as mem from '../common';\n\n/**\n * Binary key/value storage backed by native javascript array. Performs binary search on entries and\n * keeps items in sorted order based on comparer.\n */\nexport default class BinaryArray {\n  /**\n     * @param  {comparerCallback} [comparer] comparer to use when comparing one\n     * index value to another\n     */\n  constructor(comparer) {\n    this.arr = [];\n    this.comparer = comparer || mem.defaultComparer;\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.arr = [];\n  }\n\n  /**\n     * Returns an array of keys stored in this Key Value array\n     * @returns {Array<any>} all keys\n     */\n  get keys() {\n    return this.arr.map(m => m.key);\n  }\n\n  /**\n     * Returns an array of values stored in this Key Value array\n     * @returns {Array<any>} all values\n     */\n  get values() {\n    return this.arr.map(m => m.value);\n  }\n\n  /**\n     * Returns the number of items in this BinaryArray\n     * @returns {number}\n     */\n  get length() {\n    return this.arr.length;\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  lt(key) {\n    const i = this.insertPos(key);\n    const data = this.arr.slice(0, i);\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  lte(key) {\n    const i = this.insertPos(key);\n    const data = i >= 0 ? this.arr.slice(0, i + 1) : [];\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns all entries greater than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  gt(key) {\n    const i = this.insertPos(key);\n    const data = i < this.arr.length ? this.arr.slice(i + 1, this.arr.length) : [];\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  gte(key) {\n    const i = this.insertPos(key);\n    const data = i < this.arr.length ? this.arr.slice(i, this.arr.length) : [];\n    return data.map(d => d.value);\n  }\n\n  /**\n     * Returns the index in this array of the specified key\n     * @param {any} key\n     * @returns {number}\n     */\n  indexOf(key) {\n    const i = this.insertPos(key);\n    if (this.arr[i] && mem.eq(this.comparer, this.arr[i].key, key)) {\n      return i;\n    }\n    return -1;\n  }\n\n  /**\n     * The insert position where to insert an item into the underlying sorted array.\n     * @param {any} key key to find in the array\n     * @returns {number} position at which a new item should be inserted into this array\n     */\n  insertPos(key) {\n    let low = 0; let high = this.arr.length; let\n      mid;\n    while (low < high) {\n      /* eslint no-bitwise: 0 */\n      mid = (low + high) >>> 1;\n      if (mem.lt(this.comparer, this.arr[mid].key, key)) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return low;\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {any} value found\n     */\n  get(key) {\n    const i = this.indexOf(key);\n    if (i > -1) {\n      return this.arr[i].value;\n    }\n    return undefined;\n  }\n\n  /**\n     * Returns whether or not a given key exists.\n     * @param  {any} key specified index key\n     * @return {boolean} if key exists or not\n     */\n  has(key) {\n    const i = this.indexOf(key);\n    return (i > -1);\n  }\n\n  /**\n     * Removes an item by key\n     * @param  {any} key key of item to remove\n     */\n  remove(key) {\n    const i = this.indexOf(key);\n    if (i > -1) {\n      this.removeAt(i);\n    }\n  }\n\n  /**\n     * Adds an key/value with array\n     * @param  {any} key key to add\n     * @param  {any} value item related to the specified key\n     */\n  add(key, value) {\n    const ix = this.insertPos(key);\n    this.addAt(ix, key, value);\n  }\n\n  /**\n     * Replaces an existing entry in the array with a new one.\n     * @param {any} key key to add\n     * @param {any} value item related to the specified key\n     */\n  replace(key, value) {\n    const i = this.indexOf(key);\n    if (i > -1) {\n      this.replaceAt(i, key, value);\n    }\n  }\n\n  /**\n     * Adds a key/value entry at a specified position in the array.\n     * Will not replace any existing item in that postion, instead\n     * inserting before it.\n     * @param {number} pos index of where to add this entry\n     * @param {any} key key to add\n     */\n  addAt(pos, key, value) {\n    const item = { key, value };\n    this.arr.splice(pos, 0, item);\n  }\n\n  /**\n     * Replaces an existing entry in the array at specified position with a new one.\n     * @param {number} pos index of where to replace this entry\n     * @param {any} key key to add\n     * @param {any} value item related to the specified key\n     */\n  replaceAt(pos, key, value) {\n    const item = { key, value };\n    this.arr.splice(pos, 1, item);\n  }\n\n  /**\n     * Removes a key/value entry at a specified position\n     * @param {number} pos index of the item to remove.\n     */\n  removeAt(pos) {\n    this.arr.splice(pos, 1);\n  }\n\n  /**\n     * Returns key matching passed index position\n     * @param  {number} pos index of where to add this entry\n     * @return {any} key found at this position\n     */\n  getAt(pos) {\n    return this.arr[pos];\n  }\n}\n","import * as mem from '../common';\nimport BinaryArray from './binaryarray';\nimport BaseIndex from './baseindex';\n\n/**\n * Index based on BinaryArray for key/value storage. Groups items by index value,\n * stores items within index value as array using linear search.\n * @extends {BaseIndex}\n */\nexport default class BinaryIndex extends BaseIndex {\n  /**\n     * @implements {BaseIndex}\n     * @param  {string} name name of this index\n     * @param  {itemCallback} itemFn function to call to get the unique item\n     * key of the items in this index\n     * @param  {keyCallback} keyFn function to call to get the index key of the items in this index\n     * @param  {comparerCallback} [comparer] comparer to use when comparing\n     * one index value to another\n     */\n  constructor(name, itemFn, keyFn, comparer) {\n    super(name, itemFn, keyFn);\n    this.comparer = comparer || mem.defaultComparer;\n    this.index = new BinaryArray(this.comparer);\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.index.length === 0;\n  }\n\n  /**\n     * Returns all keys\n     * @return {Array<Key>}\n     */\n  get keys() {\n    return this.index.keys;\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.index = new BinaryArray(this.comparer);\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lt(key) {\n    const data = this.index.lt(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lte(key) {\n    const data = this.index.lte(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns all entries greater than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gt(key) {\n    const data = this.index.gt(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gte(key) {\n    const data = this.index.gte(key);\n    return mem.shallowFlat(data);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  $eq(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Returns items matching passed index keys\n     * @param  {Array<any>} key specified index keys\n     * @return {Array<any>} values found\n     */\n  $in(keys) {\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  find(key) {\n    return this.index.get(key);\n  }\n\n  /**\n     * Removes an item\n     * @param  {any} item item to remove\n     */\n  remove(item) {\n    const key = this.keyFn(item);\n    const pos = this.index.indexOf(key);\n\n    if (pos > -1) {\n      const entry = this.index.getAt(pos);\n      const it = this.itemFn(item);\n      const i = entry.value.indexOf(it);\n      if (i > -1) {\n        entry.value.splice(i, 1);\n      }\n      if (entry.value.length === 0) {\n        this.index.removeAt(pos);\n      }\n    }\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @param  {any} item item to add to index\n     */\n  insert(item) {\n    const key = this.keyFn(item);\n    const it = this.itemFn(item);\n    const pos = this.index.insertPos(key);\n    const entry = this.index.getAt(pos);\n\n    if (entry && mem.eq(this.comparer, entry.key, key)) {\n      entry.value.push(it);\n    } else {\n      this.index.addAt(pos, key, [it]);\n    }\n  }\n}\n","/* eslint import/no-extraneous-dependencies: [\"error\", {\"optionalDependencies\": true}] */\nimport AVLTree from 'avl';\nimport * as mem from '../common';\nimport BaseIndex from './baseindex';\n\n/**\n * Index based on AVL Tree object for key/value storage. Groups items by index value,\n * stores items within index value as array using linear search.\n * @extends {BaseIndex}\n */\nexport default class AVLIndex extends BaseIndex {\n  /**\n     * @param  {string} name name of this index\n     * @param  {itemCallback} itemFn function to call to get the unique item\n     * key of the items in this index\n     * @param  {keyCallback} keyFn function to call to get the index key\n     * of the items in this index\n     * @param  {comparerCallback} [comparer] comparer to use when comparing\n     * one index value to another\n     */\n  constructor(name, itemFn, keyFn, comparer) {\n    super(name, itemFn, keyFn);\n    this.comparer = comparer || mem.defaultComparer;\n    this.index = new AVLTree(comparer);\n  }\n\n  /**\n     * Returns whether or not this index is empty\n     * @abstract\n     * @return {boolean}\n     */\n  get isEmpty() {\n    return this.index.size === 0;\n  }\n\n  /**\n     * Returns all keys\n     * @return {Array<Key>}\n     */\n  get keys() {\n    return this.index.keys();\n  }\n\n  /**\n     * Removes all items from the index\n     */\n  clear() {\n    this.index.clear();\n  }\n\n  /**\n     * Returns all entries less than the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lt(key) {\n    let lastKey;\n    const data = [];\n    this.index.range(this.index.min, key, (n) => {\n      lastKey = n.key;\n      data.push(n.data);\n    });\n    if (data.length === 0) {\n      return [];\n    }\n    // Since Tree is unique, we only need to check last key to omit\n    if (mem.eq(this.comparer, lastKey, key)) {\n      data.pop();\n    }\n    return data;\n  }\n\n  /**\n     * Returns all entries less or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $lte(key) {\n    const data = [];\n    this.index.range(this.index.min, key, (n) => {\n      data.push(n.data);\n    });\n    return data;\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gt(key) {\n    let firstKey;\n    const data = [];\n    this.index.range(key, this.index.max, (n) => {\n      if (firstKey === undefined) {\n        firstKey = n.key;\n      }\n      data.push(n.data);\n    });\n    if (data.length === 0) {\n      return [];\n    }\n    // Since Tree is unique, we only need to check first key to omit\n    if (mem.eq(this.comparer, firstKey, key)) {\n      data.shift();\n    }\n    return data;\n  }\n\n  /**\n     * Returns all entries greater than or equal to the passed key according to the\n     * indexes comparer.\n     * @param {any} key\n     */\n  $gte(key) {\n    const data = [];\n    this.index.range(key, this.index.max, (n) => {\n      data.push(n.data);\n    });\n    return data;\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  $eq(key) {\n    return this.find(key);\n  }\n\n  /**\n     * Returns items matching passed index keys\n     * @param  {Array<any>} key specified index keys\n     * @return {Array<any>} values found\n     */\n  $in(keys) {\n    return this.findMany(keys);\n  }\n\n  /**\n     * Returns items matching passed index key\n     * @param  {any} key specified index key\n     * @return {Array<any>} values found\n     */\n  find(key) {\n    const found = this.index.find(key);\n    if (found) {\n      return found.data;\n    }\n    return [];\n  }\n\n  /**\n     * Removes an item\n     * @param  {any} item item to remove\n     */\n  remove(item) {\n    const key = this.keyFn(item);\n    const entry = this.index.find(key);\n\n    if (entry) {\n      const it = this.itemFn(item);\n      const arr = entry.data;\n      const i = arr.indexOf(it);\n      if (i > -1) {\n        arr.splice(i, 1);\n      }\n      if (arr.length === 0) {\n        this.index.remove(key);\n      }\n    }\n  }\n\n  /**\n     * Adds an item with indexes as per itemFn and keyFn defined on index creation\n     * @param  {any} item item to add to index\n     */\n  insert(item) {\n    const key = this.keyFn(item);\n    const it = this.itemFn(item);\n    const entry = this.index.find(key);\n\n    if (entry) {\n      entry.data.push(it);\n    } else {\n      this.index.insert(key, [it]);\n    }\n  }\n}\n"],"names":["const","let","mem.intersect","this","mem.oneOrMany","mem.extract","prototypeAccessors","super","mem.defaultComparer","mem.lt","mem.lte","mem.gt","mem.gte","mem.eq","mem.shallowFlat"],"mappings":"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"}